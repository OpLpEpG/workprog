<?xml version="1.0" encoding="utf-8"?>
<TRR>
	<SIMPLE_FORMAT>
		<MODEL>
			<D3A EXEC_METR="--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля ]]&#xA;&#xA;  v.T.CLC.VALUE = v.T.DEV.VALUE/4;&#xA;  v.X.CLC.VALUE = v.X.DEV.VALUE*1000;&#xA;  v.Y.CLC.VALUE = v.Y.DEV.VALUE*1000;&#xA;  v.Z.CLC.VALUE = v.Z.DEV.VALUE*1000;&#xA;" SETUP_METR="--alg, t - псевдо таблицы&#xA;--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля ]]&#xA;&#xA;  AddMetrology(v.T, '°C', '%8.1f',  -40, 150);&#xA;  AddMetrology(v.X, 'mG', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.Y, 'mG', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.Z, 'mG', '%8.1f',  -1000, 1000);&#xA;">
				<IMPORT/>
				<EXPORT/>
			</D3A>
			<EU_mV EXEC_METR="--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля ]]&#xA;" SETUP_METR="--alg, t - псевдо таблицы&#xA;--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля ]]&#xA;  v.DEV.EU = 'mV';&#xA;&#xA;--DebugLog('v.DEV', 'EU:', run_path, run_address, v.DEV.EU);&#xA;"><IMPORT/>
				<EXPORT/>
			</EU_mV><D3H EXEC_METR="--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;  v.T.CLC.VALUE = v.T.DEV.VALUE/4;&#xA;  v.X.CLC.VALUE = v.X.DEV.VALUE*1000;&#xA;  v.Y.CLC.VALUE = v.Y.DEV.VALUE*1000;&#xA;  v.Z.CLC.VALUE = v.Z.DEV.VALUE*1000;&#xA;--end;&#xA;" SETUP_METR="--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  AddMetrology(v.T, '°C', '%8.1f',  -40, 150);&#xA;&#xA;  AddMetrology(v.X, '', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.Y, '', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.Z, '', '%8.1f',  -1000, 1000);&#xA;--end;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</D3H>
			<AU EXEC_METR="--AU procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; --var&#xA;--s: string;&#xA;--au: Integer;&#xA;--begin&#xA;--{   APP_SET_TIME,&#xA; --APP_CLEAR_RAM,&#xA; --APP_DELAY,&#xA; --APP_WORK,&#xA; --APP_IDLE,}&#xA;&#xA;    local err = '';&#xA;    local s = '';&#xA;    local au;&#xA;    au = v.DEV.VALUE;&#xA; if au &gt;= 0x80 then &#xA;  au = au - 0x80;&#xA;  s = ' [контроль]';&#xA; end;&#xA; if au &gt;= 0x40 then&#xA;  au = au - 0x40;&#xA;  err = ' [ошибка]';&#xA; end &#xA;&#xA;    local t = {'Установка времени', 'Стирание памяти', 'Задержка', 'Работа', 'Выключен'};&#xA;&#xA;    if au &lt; 5 then &#xA;  v.CLC.VALUE = t[au+1]..s..err;&#xA; else&#xA;  v.CLC.VALUE = 'Ошибка !!!';&#xA; end&#xA;--end" SETUP_METR="--{ procedure (v: variant);&#xA;--  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  varString = 0x0100;&#xA;  AddXmlPath(v, 'CLC');&#xA;  v.CLC.VALUE = 'Нет Данных';&#xA;  v.CLC.TYPE = varString;&#xA;--end;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</AU>
			<WT_USO_PSK EXEC_METR="--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  v.CLC.VALUE = -v.DEV.VALUE*2.097152/2/3600/24;&#xA;--end;&#xA;" SETUP_METR="--{ procedure (v: variant);&#xA;--  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  AddXmlPath(v, 'CLC');&#xA;  varDate = 7;&#xA;  v.CLC.VALUE = Now();&#xA;  v.CLC.TYPE = varDate;&#xA;--end;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</WT_USO_PSK>
			<WT_GLU_PSK EXEC_METR="--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  v.CLC.VALUE = v.DEV.VALUE*2.097152/2/3600/24;&#xA;--end;&#xA;" SETUP_METR="--{ procedure (v: variant);&#xA;--  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  AddXmlPath(v, 'CLC');&#xA;  varDate = 7;&#xA;  v.CLC.VALUE = Now();&#xA;  v.CLC.TYPE = varDate;&#xA;--end;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</WT_GLU_PSK>
			<WT EXEC_METR="--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  v.CLC.VALUE = KadrToStr(v.DEV.VALUE);&#xA;--end;&#xA;" SETUP_METR="--{ procedure (v: variant);&#xA;--  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  AddXmlPath(v, 'CLC');&#xA;   varString   = 0x0100;&#xA;   v.CLC.VALUE = '0';&#xA;   v.CLC.TYPE = varString;&#xA;--end;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</WT>
			<D3TM EXEC_METR="--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  v.CLC.VALUE = v.DEV.VALUE/3600/24/64;&#xA;--end;&#xA;" SETUP_METR="--{ procedure (v: variant);&#xA;--  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  AddXmlPath(v, 'CLC');&#xA;  varDate = 7;&#xA;  v.CLC.VALUE = Now();&#xA;  v.CLC.TYPE = varDate;&#xA;--end;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</D3TM>
			<D3TM1 EXEC_METR="--{ procedure (v, t: variant);&#xA;--  где t - корневой элемент метрологии модуля&#xA;--  v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  v.CLC.VALUE = v.DEV.VALUE/3600/24/64;&#xA;--end;&#xA;" SETUP_METR="--{ procedure (v: variant);&#xA;--  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  AddXmlPath(v, 'CLC');&#xA;  v.CLC.VALUE = Now();&#xA;  varDate = 7;&#xA;  v.CLC.TYPE = varDate;&#xA;--end;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</D3TM1>
		</MODEL>
		<TRR_MODEL/>
	</SIMPLE_FORMAT>
	<Inclin SETUP_METR="--{ procedure (v, t, run_path, run_address: variant);&#xA;--begin&#xA;--//  тип создание ветви поправкок и заполнение значениями по умолчанию&#xA;--// косоугольность, смещение 0 амплит. акселер.&#xA; AddXmlPath(t, 'accel');&#xA;&#xA; if AddXmlMatrix(t.accel, 3,4) then -- реально добавлены&#xA;-- т.к. скрипт выполняется дважды для WRK b RAM&#xA;--// по умолранию амплит=1 остальнвые 0&#xA;-- &#xA;  t.accel.m3x4.m11 = 1;&#xA;  t.accel.m3x4.m22 = 1;&#xA;  t.accel.m3x4.m33 = 1;&#xA; end&#xA; -- AddXmlVect3D_T(t.accel);&#xA;--// косоугольность, смещение 0 амплит. магнит.&#xA;  AddXmlPath(t, 'magnit');&#xA;  if AddXmlMatrix(t.magnit, 3,4) then&#xA;--// по умолранию амплит=1 остальнвые 0&#xA;   t.magnit.m3x4.m11 = 1;&#xA;   t.magnit.m3x4.m22 = 1;&#xA;   t.magnit.m3x4.m33 = 1;&#xA;  end&#xA; -- AddXmlVect3D_T(t.magnit);&#xA;--end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<D3 EXEC_METR="--{ procedure (v, t, run_path, run_address: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;-- run_path -WRK, RAM&#xA;-- run_address - adres modulia&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; --var&#xA;  --os,oc,zs,zc,&#xA;  --a, zu, o, mo, b,&#xA;  --x,y,z, Hx, Hy, Hz: Double;&#xA;  --res: Variant;&#xA;--begin&#xA;--// получение тарированных данных&#xA;--// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;--// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;--// - четвертая размерность V[4].ROW=1&#xA;--// ROW- атрибут сырые данные с прибора&#xA; &#xA; local ax = math.abs(v.accel.X.DEV.VALUE);&#xA; local ay = math.abs(v.accel.Y.DEV.VALUE);&#xA; local az = math.abs(v.accel.Z.DEV.VALUE);&#xA; local  k = 1;&#xA;&#xA;-- if (ax &lt; 2) and (ay &lt; 2) and (az &lt; 2) then&#xA;--   k = 1000;&#xA;-- end;&#xA;&#xA; local x,y,z = TrrVect3D(t.accel.m3x4, v.accel, k);&#xA; v['амплит_accel'].CLC.VALUE = Hypot3D(x, y, z);&#xA;&#xA; local o = math.atan(y, -x);&#xA; local zu = math.atan(Hypot(x, y), z);--]]&#xA;&#xA; local x,y,z = TrrVect3D(t.magnit.m3x4, v.magnit, k);&#xA;---- TEST&#xA; ---z = z - 55;&#xA;---- TEST&#xA; v['амплит_magnit'].CLC.VALUE = Hypot3D(x, y, z);--]]&#xA;&#xA; local mo = math.atan(y, -x);&#xA;&#xA; local os = math.sin(o);&#xA; local oc = math.cos(o);&#xA; local zs = math.sin(zu);&#xA; local zc = math.cos(zu);&#xA;&#xA; local Hx = (x*oc - y*os)*zc + z*zs;&#xA; local Hy =  x*os + y*oc;&#xA; local Hz =-(x*oc - y*os)*zs + z*zc;&#xA;&#xA; local a = -math.atan(Hy, Hx);&#xA; local b = math.atan(Hypot(Hx, Hy), Hz);--]]&#xA;&#xA; v['зенит'].CLC.VALUE       = RadToDeg180(zu);&#xA; v['азимут'].CLC.VALUE      = RadToDeg360(a);&#xA; v['отклонитель'].CLC.VALUE = RadToDeg360(o);&#xA; v['маг_отклон'].CLC.VALUE  = RadToDeg360(mo);&#xA; v['маг_наклон'].CLC.VALUE  = RadToDeg360(b);--]]&#xA;&#xA; v.accel.T.CLC.VALUE = v.accel.T.DEV.VALUE/4;&#xA; v.magnit.T.CLC.VALUE = v.magnit.T.DEV.VALUE/4;--]]&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;  m = AddMetrology(v.accel.T, 'accel.T', '°C');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -100, 100);&#xA;  AddMetrologyCL(m, 0xFF4F0000, 1, 1);&#xA;&#xA;  m = AddMetrology(v.magnit.T, 'magnit.T', '°C');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -100, 100);&#xA;  AddMetrologyCL(m, 0xFF4F0000, 1, 1);&#xA;&#xA;&#xA;  m = AddMetrology(v.accel.X, 'Gx', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFFFF0000, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.Y, 'Gy', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF00FF00, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.Z, 'Gz', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF0000FF, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.X.DEV, 'gx', '');&#xA;  AddMetrologyFM(m, 8, 4);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x808F0000, 1, 1);&#xA;  m = AddMetrology(v.accel.Y.DEV, 'gy', '');&#xA;  AddMetrologyFM(m, 8, 4);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80008F00, 1, 1);&#xA;  m = AddMetrology(v.accel.Z.DEV, 'gz', '');&#xA;  AddMetrologyFM(m, 8, 4);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x8000008F, 1, 1);&#xA;&#xA;  m = AddMetrology(v.magnit.X, 'HX', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF800000);&#xA;&#xA;  m = AddMetrology(v.magnit.Y, 'HY', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF008000);&#xA;&#xA;  m = AddMetrology(v.magnit.Z, 'HZ', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF000080);&#xA;&#xA;  m = AddMetrology(v.magnit.X.DEV, 'hx', '');&#xA;  AddMetrologyFM(m, 8, 4);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80804000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Y.DEV, 'hy', '');&#xA;  AddMetrologyFM(m, 8, 4);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80408000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Z.DEV, 'hz', '');&#xA;  AddMetrologyFM(m, 8, 4);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80004080, 1, 1);&#xA;&#xA;  --// вычисляемые параметры&#xA;  AddXmlPath(v, 'зенит');&#xA;  v['зенит'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['зенит'], 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0800080, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'азимут');&#xA;  v['азимут'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['азимут'], 'азимут', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0800000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'отклонитель');&#xA;  v['отклонитель'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['отклонитель'], 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0404000, 2, 1);&#xA;&#xA;  AddXmlPath(v, 'маг_отклон');&#xA;  v[&quot;маг_отклон&quot;].METR = 'ANGLE';&#xA;  m = AddMetrology(v[&quot;маг_отклон&quot;], 'маг.визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'маг_наклон');&#xA;  v[&quot;маг_наклон&quot;].METR = 'ANGLE';&#xA;  m = AddMetrology(v[&quot;маг_наклон&quot;], 'маг.наклон', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0804000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'амплит_accel');&#xA;  m = AddMetrology(v['амплит_accel'], 'G', 'mG');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, 0xC0408000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'амплит_magnit');&#xA;  m = AddMetrology(v['амплит_magnit'], 'H', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, 0xC0404080, 2, 2);&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</D3>
			<D3_TESESIS EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; --var&#xA;  --os,oc,zs,zc,&#xA;  --a, zu, o, mo, b,&#xA;---  x,y,z, Hx, Hy, Hz: Double;&#xA;--  res: Variant;&#xA;--begin&#xA;--// получение тарированных данных&#xA;--// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;--// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;--// - четвертая размерность V[4].ROW=1&#xA;--// ROW- атрибут сырые данные с прибора&#xA;  local x,y,z = TrrVect3D(t.accel.m3x4, v.accel);--//, 1000);&#xA;  v['амплит_accel'].CLC.VALUE = Hypot3D(x, y, z);&#xA;&#xA;  o = ArcTan2(y, -x);&#xA;  zu = ArcTan2(Hypot(x, y), z);&#xA;&#xA;  local x,y,z = TrrVect3D(t.magnit.m3x4, v.magnit);--//, 1000);&#xA;  v['амплит_magnit'].CLC.VALUE = Hypot3D(x, y, z);&#xA;&#xA;  mo = Arctan2(y, -x) + 3.1415926536; --// нужен +180  в нуле;&#xA;&#xA;  os = math.sin(o);&#xA;  oc = math.cos(o);&#xA;  zs = math.sin(zu);&#xA;  zc = math.cos(zu);&#xA;&#xA;  Hx = (x*oc - y*os)*zc + z*zs;&#xA;  Hy =  x*os + y*oc;&#xA;  Hz =-(x*oc - y*os)*zs + z*zc;&#xA;&#xA;  a = -ArcTan2(Hy, Hx);&#xA;  b = ArcTan2(Hypot(Hx, Hy), Hz);&#xA;&#xA;  v['зенит'].CLC.VALUE       = RadToDeg_0_180(zu);&#xA;  v['азимут'].CLC.VALUE      = RadToDeg_0_360(a);&#xA;  v['отклонитель'].CLC.VALUE = RadToDeg_0_360(o);&#xA;  v['маг_отклон'].CLC.VALUE  = RadToDeg_0_360(mo);&#xA;  v['маг_наклон'].CLC.VALUE  = RadToDeg_0_360(b);&#xA;&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;  m = AddMetrology(v.accel.DXY.DEV, 'dXY', 'mG');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x7F00004F, 1, 1);&#xA;&#xA;  m = AddMetrology(v.accel.DZ.DEV, 'dZ', 'mG');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x7F00004F, 1, 1);&#xA;&#xA;  m = AddMetrology(v.accel.X, 'GX', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFFFF0000, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.Y, 'GY', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF00FF00, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.Z, 'GZ', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF0000FF, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.X.DEV, 'gx', '');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x808F0000, 1, 1);&#xA;  m = AddMetrology(v.accel.Y.DEV, 'gy', '');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80008F00, 1, 1);&#xA;  m = AddMetrology(v.accel.Z.DEV, 'gz', '');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x8000008F, 1, 1);&#xA;&#xA;  m = AddMetrology(v.magnit.X, 'HX', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF800000);&#xA;&#xA;  m = AddMetrology(v.magnit.Y, 'HY', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF008000);&#xA;&#xA;  m = AddMetrology(v.magnit.Z, 'HZ', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF000080);&#xA;&#xA;  m = AddMetrology(v.magnit.X.DEV, 'hx', '');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80804000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Y.DEV, 'hy', '');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80408000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Z.DEV, 'hz', '');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80004080, 1, 1);&#xA;&#xA;  --// вычисляемые параметры&#xA;  AddXmlPath(v, 'зенит');&#xA;  v['зенит.METR'] = 'ANGLE';&#xA;  m = AddMetrology(v['зенит'], 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0800080, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'азимут');&#xA;  v['азимут'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['азимут'], 'азимут', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0800000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'отклонитель');&#xA;  v['отклонитель'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['отклонитель'], 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0404000, 2, 1);&#xA;&#xA;  AddXmlPath(v, 'маг_отклон');&#xA;  v['маг_отклон'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_отклон'], 'маг.визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'маг_отклон1');&#xA;  v['маг_отклон1'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_отклон1'], 'визир1', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;  AddXmlPath(v, 'маг_отклон2');&#xA;  v['маг_отклон2'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_отклон2'], 'визир2', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;  AddXmlPath(v, 'маг_отклон3');&#xA;  v['маг_отклон3'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_отклон3'], 'визир3', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;&#xA;  m = AddMetrology(v['маг_отклон1'].DEV, 'маг.визир1', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;  m = AddMetrology(v['маг_отклон2'].DEV, 'маг.визир2', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;  m = AddMetrology(v['маг_отклон3'].DEV, 'маг.визир3', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'маг_наклон');&#xA;  v['маг_наклон'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_наклон'], 'маг.наклон', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0804000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'амплит_accel');&#xA;  m = AddMetrology(v['амплит_accel'], 'A', 'mG');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, 0xC0408000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'амплит_magnit');&#xA;  m = AddMetrology(v['амплит_magnit'], 'H', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, 0xC0404080, 2, 2);&#xA;&#xA;&#xA;  AddXmlPath(v, 'статика.отклонитель');&#xA;  v['статика']['отклонитель'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['статика']['отклонитель'], 'статика.визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0404000, 2, 1);&#xA;&#xA;  AddXmlPath(v, 'статика.маг_отклон');&#xA;  v['статика']['маг_отклон'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['статика']['маг_отклон'], 'статика.маг.визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</D3_TESESIS>
			<DPSK EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; --var&#xA;  --os,oc,zs,zc,&#xA;--  a, zu, o, mo, b,&#xA;--  x,y,z, Hx, Hy, Hz: Double;&#xA;--  res: Variant;&#xA;--begin&#xA;--// получение тарированных данных&#xA;--// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;--// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;--// - четвертая размерность V[4].ROW=1&#xA;--// ROW- атрибут сырые данные с прибора&#xA;  local x,y,z = TrrVect3D(t.accel.m3x4, v.accel);--//, 1000);&#xA;  v['амплит_accel'].CLC.VALUE = Hypot3D(x, y, z);&#xA;&#xA;  o = ArcTan2(y, -x);&#xA;  zu = ArcTan2(Hypot(x, y), z);&#xA;&#xA;  local x,y,z = TrrVect3D(t.magnit.m3x4, v.magnit);--//, 1000);&#xA;  v['амплит_magnit'].CLC.VALUE = Hypot3D(x, y, z);&#xA;&#xA;  mo = ArcTan2(y, -x);&#xA;&#xA;  os = math.sin(o);&#xA;  oc = math.cos(o);&#xA;  zs = math.sin(zu);&#xA;  zc = math.cos(zu);&#xA;&#xA;  Hx = (x*oc - y*os)*zc + z*zs;&#xA;  Hy =  x*os + y*oc;&#xA;  Hz =-(x*oc - y*os)*zs + z*zc;&#xA;&#xA;  a = -ArcTan2(Hy, Hx);&#xA;  b = ArcTan2(Hypot(Hx, Hy), Hz);&#xA;&#xA;  v['зенит'].CLC.VALUE       = RadToDeg180(zu);&#xA;  v['азимут'].CLC.VALUE      = RadToDeg360(a);&#xA;  v['отклонитель'].CLC.VALUE = RadToDeg360(o);&#xA;  v['маг_отклон'].CLC.VALUE  = RadToDeg360(mo);&#xA;  v['маг_наклон'].CLC.VALUE  = RadToDeg360(b);&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m = AddMetrology(v.accel.X, 'GX', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFFFF0000, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.Y, 'GY', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF00FF00, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.Z, 'GZ', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF0000FF, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.X.DEV, 'gx', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x808F0000, 1, 1);&#xA;  m = AddMetrology(v.accel.Y.DEV, 'gy', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x80008F00, 1, 1);&#xA;  m = AddMetrology(v.accel.Z.DEV, 'gz', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x8000008F, 1, 1);&#xA;&#xA;  m = AddMetrology(v.magnit.X, 'HX', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF800000);&#xA;&#xA;  m = AddMetrology(v.magnit.Y, 'HY', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF008000);&#xA;&#xA;  m = AddMetrology(v.magnit.Z, 'HZ', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF000080);&#xA;&#xA;  m = AddMetrology(v.magnit.X.DEV, 'hx', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80804000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Y.DEV, 'hy', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80408000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Z.DEV, 'hz', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80004080, 1, 1);&#xA;&#xA;--  // вычисляемые параметры&#xA;  AddXmlPath(v, 'зенит');&#xA;  v['зенит'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['зенит'], 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0800080, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'азимут');&#xA;  v['азимут'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['азимут'], 'азимут', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0800000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'отклонитель');&#xA;  v['отклонитель'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['отклонитель'], 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0404000, 2, 1);&#xA;&#xA;  AddXmlPath(v, 'маг_отклон');&#xA;  v['маг_отклон'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_отклон'], 'маг.визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'маг_наклон');&#xA;  v['маг_наклон'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_наклон'], 'маг.наклон', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0804000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'амплит_accel');&#xA;  m = AddMetrology(v['амплит_accel'], 'G', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, 0xC0408000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'амплит_magnit');&#xA;  m = AddMetrology(v['амплит_magnit'], 'H', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, 0xC0404080, 2, 2);&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</DPSK>
			<INKLGK EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; --var&#xA;  --os,oc,zs,zc,&#xA;--  a, zu, o, mo, b,&#xA;--  x,y,z, Hx, Hy, Hz: Double;&#xA;--  res: Variant;&#xA;--begin&#xA;--// получение тарированных данных&#xA;--// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;--// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;--// - четвертая размерность V[4].ROW=1&#xA;--// ROW- атрибут сырые данные с прибора&#xA;  local x,y,z = TrrVect3D(t.accel.m3x4, v.accel);--//, 1000);&#xA;  v['амплит_accel'].CLC.VALUE = Hypot3D(x, y, z);&#xA;&#xA;  o = ArcTan2(y, -x);&#xA;  zu = ArcTan2(Hypot(x, y), z);&#xA;&#xA;  local x,y,z = TrrVect3D(t.magnit.m3x4, v.magnit);--//, 1000);&#xA;  v['амплит_magnit'].CLC.VALUE = Hypot3D(x, y, z);&#xA;&#xA;  mo = ArcTan2(y, -x);&#xA;&#xA;  os = math.sin(o);&#xA;  oc = math.cos(o);&#xA;  zs = math.sin(zu);&#xA;  zc = math.cos(zu);&#xA;&#xA;  Hx = (x*oc - y*os)*zc + z*zs;&#xA;  Hy =  x*os + y*oc;&#xA;  Hz =-(x*oc - y*os)*zs + z*zc;&#xA;&#xA;  a = -ArcTan2(Hy, Hx);&#xA;  b = ArcTan2(Hypot(Hx, Hy), Hz);&#xA;&#xA;  v['зенит'].CLC.VALUE       = RadToDeg180(zu);&#xA;  v['азимут'].CLC.VALUE      = RadToDeg360(a);&#xA;  v['отклонитель'].CLC.VALUE = RadToDeg360(o);&#xA;  v['маг_отклон'].CLC.VALUE  = RadToDeg360(mo);&#xA;  v['маг_наклон'].CLC.VALUE  = RadToDeg360(b);&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;&#xA;  m = AddMetrology(v.accel.X, 'GX', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFFFF0000, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.Y, 'GY', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF00FF00, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.Z, 'GZ', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF0000FF, 3, 1);&#xA;&#xA;  m = AddMetrology(v.accel.X.DEV, 'gx', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x808F0000, 1, 1);&#xA;  m = AddMetrology(v.accel.Y.DEV, 'gy', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x80008F00, 1, 1);&#xA;  m = AddMetrology(v.accel.Z.DEV, 'gz', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x8000008F, 1, 1);&#xA;&#xA;  m = AddMetrology(v.magnit.X, 'HX', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF800000);&#xA;&#xA;  m = AddMetrology(v.magnit.Y, 'HY', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF008000);&#xA;&#xA;  m = AddMetrology(v.magnit.Z, 'HZ', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF000080);&#xA;&#xA;  m = AddMetrology(v.magnit.X.DEV, 'hx', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x80804000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Y.DEV, 'hy', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x80408000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Z.DEV, 'hz', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x80004080, 1, 1);&#xA;&#xA;  m = AddMetrology(v.T.DEV, 'темпр', '°C');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -40, 150);&#xA;  AddMetrologyCL(m, 0x80004080, 2, 3);&#xA;&#xA;--  // вычисляемые параметры&#xA;--  //AddXmlPath(v, 'зенит');&#xA;  v['зенит'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['зенит'], 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0800080, 2, 2);&#xA;  m = AddMetrology(v['зенит'].DEV, 'zen', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;&#xA;  --//AddXmlPath(v, 'азимут');&#xA;  v['азимут'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['азимут'], 'азимут', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0800000, 2, 2);&#xA;  m = AddMetrology(v['азимут'].DEV, 'azm', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;&#xA;  --//AddXmlPath(v, 'отклонитель');&#xA;  v['отклонитель'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['отклонитель'], 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0404000, 2, 1);&#xA;  m = AddMetrology(v['отклонитель'].DEV, 'viz', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;&#xA;  --//AddXmlPath(v, 'маг_отклон');&#xA;  v['маг_отклон'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_отклон'], 'маг.визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;  m = AddMetrology(v['маг_отклон'].DEV, 'm.viz', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;&#xA;  AddXmlPath(v, 'маг_наклон');&#xA;  v['маг_наклон'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_наклон'], 'маг.наклон', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0804000, 2, 2);&#xA;&#xA;--  //AddXmlPath(v, 'амплит_accel');&#xA;  m = AddMetrology(v['амплит_accel'], 'G', 'mG');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 2000);&#xA;  AddMetrologyCL(m, 0xC0408000, 2, 2);&#xA;  m = AddMetrology(v['амплит_accel'].DEV, 'dev.G', 'mG');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;&#xA;-- // AddXmlPath(v, 'амплит_magnit');&#xA;  m = AddMetrology(v['амплит_magnit'], 'H', 'mG');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 2000);&#xA;  AddMetrologyCL(m, 0xC0404080, 2, 2);&#xA;  m = AddMetrology(v['амплит_magnit'].DEV, 'dev.H', 'mG');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;--end;&#xA;&#xA;"><IMPORT/>
				<EXPORT/>
			</INKLGK><ADXL354 EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; --var&#xA;--  os,oc,zs,zc,&#xA;--  a, zu, o, mo, b,&#xA;--  x,y,z, Hx, Hy, Hz: Double;&#xA;--  res: Variant;&#xA;--begin&#xA;--// получение тарированных данных&#xA;--// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;--// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;--// - четвертая размерность V[4].ROW=1&#xA;--// ROW- атрибут сырые данные с прибора&#xA;&#xA; -- TrrVect3D(t.accel.m3x4, v.accel);--//, 1000);&#xA;  x = v.accel.X.DEV.VALUE;&#xA;  y = v.accel.Y.DEV.VALUE;&#xA;  z = v.accel.Z.DEV.VALUE;&#xA;  v['амплит_accel'].CLC.VALUE = Hypot3D(x, y, z);&#xA;&#xA;  o = ArcTan2(y, -x);&#xA;  zu = ArcTan2(Hypot(x, y), z);&#xA;&#xA; -- TrrVect3D(t.magnit.m3x4, v.magnit);--//, 1000);&#xA;  x = v.magnit.X.DEV.VALUE;&#xA;  y = v.magnit.Y.DEV.VALUE;&#xA;  z = v.magnit.Z.DEV.VALUE;&#xA;  v['амплит_magnit'].CLC.VALUE = Hypot3D(x, y, z); &#xA;&#xA;  mo = ArcTan2(y, -x);&#xA;&#xA;  os = math.sin(o);&#xA;  oc = math.cos(o);&#xA;  zs = math.sin(zu);&#xA;  zc = math.cos(zu);&#xA;&#xA;  Hx = (x*oc - y*os)*zc + z*zs;&#xA;  Hy =  x*os + y*oc;&#xA;  Hz =-(x*oc - y*os)*zs + z*zc;&#xA;&#xA;  a = -ArcTan2(Hy, Hx);&#xA;  b = ArcTan2(Hypot(Hx, Hy), Hz);&#xA;&#xA;  v['зенит'].CLC.VALUE       = RadToDeg180(zu);&#xA;  v['азимут'].CLC.VALUE      = RadToDeg360(a);&#xA;  v['отклонитель'].CLC.VALUE = RadToDeg360(o);&#xA;  v['маг_отклон'].CLC.VALUE  = RadToDeg360(mo);&#xA;  v['маг_наклон'].CLC.VALUE  = RadToDeg360(b);&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;  m = AddMetrology(v.accel.X.DEV, 'gx', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x808F0000, 1, 1);&#xA;  m = AddMetrology(v.accel.Y.DEV, 'gy', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x80008F00, 1, 1);&#xA;  m = AddMetrology(v.accel.Z.DEV, 'gz', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x8000008F, 1, 1);&#xA;&#xA;  m = AddMetrology(v.magnit.X.DEV, 'hx', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x80804000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Y.DEV, 'hy', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x80408000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Z.DEV, 'hz', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x80004080, 1, 1);&#xA;&#xA;  m = AddMetrology(v.T.DEV, 'темпр', '°C');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -40, 150);&#xA;  AddMetrologyCL(m, 0x80004080, 2, 3);&#xA;&#xA;--  // вычисляемые параметры&#xA;--  //AddXmlPath(v, 'зенит');&#xA;  v['зенит'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['зенит'], 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0800080, 2, 2);&#xA;  m = AddMetrology(v['зенит'].DEV, 'zen', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;&#xA;  --//AddXmlPath(v, 'азимут');&#xA;  v['азимут'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['азимут'], 'азимут', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0800000, 2, 2);&#xA;  m = AddMetrology(v['азимут'].DEV, 'azm', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;&#xA;  --//AddXmlPath(v, 'отклонитель');&#xA;  v['отклонитель'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['отклонитель'], 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0404000, 2, 1);&#xA;  m = AddMetrology(v['отклонитель'].DEV, 'viz', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;&#xA;  --//AddXmlPath(v, 'маг_отклон');&#xA;  v['маг_отклон'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_отклон'], 'маг.визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0303000, 2, 2);&#xA;  m = AddMetrology(v['маг_отклон'].DEV, 'm.viz', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;&#xA;  AddXmlPath(v, 'маг_наклон');&#xA;  v['маг_наклон'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['маг_наклон'], 'маг.наклон', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0804000, 2, 2);&#xA;&#xA;--  //AddXmlPath(v, 'амплит_accel');&#xA;  m = AddMetrology(v['амплит_accel'], 'G', 'mG');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 2000);&#xA;  AddMetrologyCL(m, 0xC0408000, 2, 2);&#xA;  m = AddMetrology(v['амплит_accel'].DEV, 'dev.G', 'mG');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;&#xA;-- // AddXmlPath(v, 'амплит_magnit');&#xA;  m = AddMetrology(v['амплит_magnit'], 'H', 'mG');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 2000);&#xA;  AddMetrologyCL(m, 0xC0404080, 2, 2);&#xA;  m = AddMetrology(v['амплит_magnit'].DEV, 'dev.H', 'mG');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</ADXL354>
		</MODEL>
		<TRR_MODEL>
			<P_1>
				<IMPORT IMPORT0="function GetFilterName()&#xA;&#xA;  return 'Импортирование из Inc (*.inc)|*.inc';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;&#xA;  ImportIncFile(TrrFile, NewTrr);&#xA;end&#xA;"/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr);&#xA;&#xA;  ExportP1ToCalc(TrrFile, NewTrr);&#xA;end&#xA;"/>
			</P_1>
			<P_2>
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;&#xA;  ExportP2ToCalc(TrrFile, NewTrr);&#xA;end&#xA;" EXPORT1="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в печать диаграмм(*.inc)|*.inc';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;&#xA;  ExportToInc( TrrFile, NewTrr);&#xA;end&#xA;" EXPORT2="function GetFilterName()&#xA;&#xA;  return 'унифицированная процепура осздания отчета (*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA;--//       TrrFile -- файл тарировки&#xA;-- //       NewTrr -- источник данных&#xA;-- //       'ReportNNK1.ods' -- шаблон в Devices&#xA;-- //       'ReportNNK1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  ExportToCalc('Report.InclT64.ods', 'Report.InclT64.xml', TrrFile, NewTrr);&#xA;end&#xA;"/>
			</P_2>
			<P_3>
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportP3ToCalc(TrrFile, NewTrr);&#xA;end&#xA;" EXPORT1="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в печать диаграмм(*.inc)|*.inc';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportToInc( TrrFile, NewTrr);&#xA;end&#xA;"/>
			</P_3>
			<P_4>
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportP4ToCalc(TrrFile, NewTrr);&#xA;end&#xA;" EXPORT1="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в печать диаграмм(*.inc)|*.inc';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportToInc( TrrFile, NewTrr);&#xA;end&#xA;"/>
			</P_4>
			<T12>
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в печать диаграмм(*.inc)|*.inc';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportToInc( TrrFile, NewTrr);&#xA;end&#xA;"/>
			</T12>
			<T_OLD>
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в печать диаграмм(*.inc)|*.inc';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportToInc( TrrFile, NewTrr);&#xA;end&#xA;"/>
			</T_OLD>
		</TRR_MODEL>
	</Inclin>
	<InclinT SETUP_METR="--begin&#xA;--//  тип создание ветви поправкок и заполнение значениями по умолчанию&#xA;--// косоугольность, смещение 0 амплит. акселер.&#xA; -- AddXmlPath(t, 'accel');&#xA;--  AddXmlMatrix(t.accel, 3,4);&#xA;--// по умолранию амплит=1 остальнвые 0&#xA;--  t.accel.m3x4.m11 = 1;&#xA;--  t.accel.m3x4.m22 = 1;&#xA;--  t.accel.m3x4.m33 = 1;&#xA; -- AddXmlVect3D_T(t.accel);&#xA;--// косоугольность, смещение 0 амплит. магнит.&#xA;--  AddXmlPath(t, 'magnit');&#xA;--  AddXmlMatrix(t.magnit, 3,4);&#xA;--// по умолранию амплит=1 остальнвые 0&#xA;--  t.magnit.m3x4.m11 = 1;&#xA;--  t.magnit.m3x4.m22 = 1;&#xA; -- t.magnit.m3x4.m33 = 1;&#xA; -- AddXmlVect3D_T(t.magnit);&#xA;--end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<DPSK_T EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; --var&#xA;  --os,oc,zs,zc,&#xA;--  a, zu, o, mo, b,&#xA;--  x,y,z, Hx, Hy, Hz: Double;&#xA;--  res: Variant;&#xA;--begin&#xA;--// получение тарированных данных&#xA;--// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;--// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;--// - четвертая размерность V[4].ROW=1&#xA;--// ROW- атрибут сырые данные с прибора&#xA; -- local tem = v.T.DEV.VALUE &#xA;--  local x,y,z = TrrVect3D_T(t.accel.T, v.accel, tem);--//, 1000);&#xA;--  local x,y,z = TrrVect3D_T(t.magnit.T, v.magnit, tem);--//, 1000);&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;&#xA;--[[&#xA;метрологию надо переделать DPSK_T на одну глобальную&#xA;--]]&#xA;  m = AddMetrology(v.accel.X.DEV, 'ax', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x808F0000, 1, 1);&#xA;  m = AddMetrology(v.accel.Y.DEV, 'ay', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x80008F00, 1, 1);&#xA;  m = AddMetrology(v.accel.Z.DEV, 'az', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x8000008F, 1, 1);&#xA;&#xA;  m = AddMetrology(v.magnit.X.DEV, 'hx', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80804000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Y.DEV, 'hy', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80408000, 1, 1);&#xA;  m = AddMetrology(v.magnit.Z.DEV, 'hz', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0x80004080, 1, 1);&#xA;&#xA;  m = AddMetrology(v.T.DEV, 'темпр', '°C');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -40, 150);&#xA;  AddMetrologyCL(m, 0x80004080, 2, 3);&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</DPSK_T>
		</MODEL>
		<TRR_MODEL>
			<InclTem1 SETUP_METR="local W ={&#xA;  {1, 'Gz1=Gz2=Gz3=Gz4=Gz5=max', {{'Zenit_Stol',0}, {'Azimut_Stol',0}}},&#xA;  {2, 'Hz1=Hz2=Hz3=Hz4=Hz5=max', {{'Zenit_StolPA',0}}},&#xA;  {3, 'Gx1=Gx5=max; Gx3=min; Gy2=min;Gy4=max.', {{'Vizir_Stol',0}, {'Azimut_Stol',90}, {'Zenit_Stol',90}}},&#xA;  {4, 'Hx1=Hy1=Hx5=Hy5=max; Hx3=Hx3=min', {{'Vizir_StolPA',0}}},&#xA;  {5, 'Gy1=Gy5=min; Gy3=max; Gx2=min;Gx4=max', {{'Vizir_Stol',90}}},&#xA;  {6, 'Hx2=Hy2=max; Hx4=Hy4=min', {{'Vizir_StolPA',90}}},&#xA;  {7, 'Gx1=Gx5=min; Gx3=max; Gy2=max;Gy4=min', {{'Vizir_Stol',180}}},&#xA;  {8, 'Hx1=Hy1=Hx5=Hy5=min; Hx3=Hx3=max', {{'Vizir_StolPA',180}}},&#xA;  {9, 'Gy1=Gy5=max;Gy3=min;Gx2=max;Gx4=min', {{'Vizir_Stol',270}}},&#xA;  {10, 'Hx2=Hy2=min; Hx4=Hy4=max', {{'Vizir_StolPA',270}}},&#xA;  {11, 'Gz1=Gz2=Gz3=Gz4=Gz5=min', {{'Azimut_Stol',0}, {'Zenit_Stol',180}}},&#xA;  {12, 'Hz1=Hz2=Hz3=Hz4=Hz5=min',  {{'Zenit_StolPA',180}}},&#xA;  &#xA;  {13, 'ЗУ=90', {{'Zenit_Stol',90}}},&#xA;  {14, 'Нагрев до 125 градусов', {{'Temp_Nagr', 125}}},&#xA;  &#xA;  {15, 'Gz1=Gz2=Gz3=Gz4=Gz5=max', {{'Zenit_Stol',0}}},&#xA;  {16, 'Hz1=Hz2=Hz3=Hz4=Hz5=max', {{'Zenit_StolPA',0}}},&#xA;  {17, 'Hx2=Hy2=min; Hx4=Hy4=max', {{'Azimut_Stol',90}, {'Zenit_Stol',90}}},&#xA;  {18, 'Gy1=Gy5=max;Gy3=min;Gx2=max;Gx4=min', {{'Vizir_Stol',270}}},&#xA;  {19, 'Hx1=Hy1=Hx5=Hy5=min; Hx3=Hx3=max', {{'Vizir_StolPA',180}}},&#xA;  {20, 'Gx1=Gx5=min; Gx3=max; Gy2=max;Gy4=min', {{'Vizir_Stol',180}}},&#xA;  {21, 'Hx2=Hy2=max; Hx4=Hy4=min', {{'Vizir_StolPA',90}}},&#xA;  {22, 'Gy1=Gy5=min; Gy3=max; Gx2=min;Gx4=max', {{'Vizir_Stol',90}}},&#xA;  {23, 'Hx1=Hy1=Hx5=Hy5=max; Hx3=Hx3=min', {{'Vizir_StolPA',0}}},&#xA;  {24, 'Gx1=Gx5=max; Gx3=min; Gy2=min;Gy4=max.', {{'Vizir_Stol',0}}},&#xA;  {25, 'Gz1=Gz2=Gz3=Gz4=Gz5=min', {{'Azimut_Stol',0}, {'Zenit_Stol',180}}},&#xA;  {26, 'Hz1=Hz2=Hz3=Hz4=Hz5=min',  {{'Zenit_StolPA',180}}},&#xA;&#xA;  {27, 'ЗУ=90', {{'Zenit_Stol',90}}},&#xA;  {28, 'Остывание до 100 градусов', {{'Temp_Ost', 100}}},&#xA;  &#xA;  {29, 'Gz1=Gz2=Gz3=Gz4=Gz5=max', {{'Zenit_Stol',0}}},&#xA;  {30, 'Hz1=Hz2=Hz3=Hz4=Hz5=max', {{'Zenit_StolPA',0}}},&#xA;  {31, 'Gx1=Gx5=max; Gx3=min; Gy2=min;Gy4=max.', {{'Azimut_Stol',90}, {'Zenit_Stol',90}}},&#xA;  {32, 'Hx1=Hy1=Hx5=Hy5=max; Hx3=Hx3=min', {{'Vizir_StolPA',0}}},&#xA;  {33, 'Gy1=Gy5=min; Gy3=max; Gx2=min;Gx4=max', {{'Vizir_Stol',90}}},&#xA;  {34, 'Hx2=Hy2=max; Hx4=Hy4=min', {{'Vizir_StolPA',90}}},&#xA;  {35, 'Gx1=Gx5=min; Gx3=max; Gy2=max;Gy4=min', {{'Vizir_Stol',180}}},&#xA;  {36, 'Hx1=Hy1=Hx5=Hy5=min; Hx3=Hx3=max', {{'Vizir_StolPA',180}}},&#xA;  {37, 'Gy1=Gy5=max;Gy3=min;Gx2=max;Gx4=min', {{'Vizir_Stol',270}}},&#xA;  {38, 'Hx2=Hy2=min; Hx4=Hy4=max', {{'Vizir_StolPA',270}}},&#xA;  {39, 'Gz1=Gz2=Gz3=Gz4=Gz5=min', {{'Azimut_Stol',0}, {'Zenit_Stol',180}}},&#xA;  {40, 'Hz1=Hz2=Hz3=Hz4=Hz5=min',  {{'Zenit_StolPA',180}}},&#xA;&#xA;  {41, 'Остывание до 32 градусов &quot;Измерения проводятся на следующий день&quot; ', {{'Temp_Ost', 32}}},&#xA;&#xA;  {42, 'Hz1=Hz2=Hz3=Hz4=Hz5=min',{}},&#xA;  {43, 'Gz1=Gz2=Gz3=Gz4=Gz5=min', {{'Zenit_Stol',180}}},&#xA;  {44, 'Hx2=Hy2=min; Hx4=Hy4=max',{{'Azimut_Stol',90}, {'Zenit_Stol',90}}},&#xA;  {45, 'Gy1=Gy5=max;Gy3=min;Gx2=max;Gx4=min', {{'Vizir_Stol',270}}},&#xA;  {46, 'Hx1=Hy1=Hx5=Hy5=min; Hx3=Hx3=max', {{'Vizir_StolPA',180}}},&#xA;  {47, 'Gx1=Gx5=min; Gx3=max; Gy2=max;Gy4=min', {{'Vizir_Stol',180}}}, &#xA;  {48, 'Hx2=Hy2=max; Hx4=Hy4=min', {{'Vizir_StolPA',90}}},&#xA;  {49, 'Gy1=Gy5=min; Gy3=max; Gx2=min;Gx4=max', {{'Vizir_Stol',90}}}, &#xA;  {50, 'Hx1=Hy1=Hx5=Hy5=max; Hx3=Hx3=min', {{'Vizir_StolPA',0}}},&#xA;  {51, 'Gx1=Gx5=max; Gx3=min; Gy2=min;Gy4=max.', {{'Vizir_Stol',0}}},&#xA;  {52, 'Hz1=Hz2=Hz3=Hz4=Hz5=max', {{'Zenit_StolPA',0},{'Azimut_Stol',0}}},&#xA;  {53, 'Gz1=Gz2=Gz3=Gz4=Gz5=min', {{'Zenit_Stol',0}}},&#xA;&#xA;};&#xA;&#xA;  findHG = function (stp, root)&#xA;    local s = AddXmlPath(stp, root);&#xA;    AddXmlPath(s, 'X.DEV');&#xA;    AddXmlPath(s, 'Y.DEV');&#xA;    AddXmlPath(s, 'Z.DEV');&#xA;    s.X.DEV.VALUE = 0;&#xA;    s.Y.DEV.VALUE = 0;&#xA;    s.Z.DEV.VALUE = 0;   &#xA;  end&#xA;&#xA;  for key, val in next, W do&#xA;--   begin&#xA;   local s = AddXmlPath(t, 'STEP'..key);&#xA;    s.EXECUTED = false;&#xA;    s.STEP = val[1];&#xA;    s.INFO = val[2];&#xA;    for i = 1, 5 do &#xA;  findHG(s, 'Inclin'..i..'.accel');&#xA;  findHG(s, 'Inclin'..i..'.magnit');&#xA;        local tmp = AddXmlPath(s, 'Inclin'..i..'.T.DEV');&#xA;        tmp.VALUE = 0;&#xA;    end&#xA;    local e = AddXmlPath(s,'TASK');&#xA;    for tkey, tval in next, val[3] do&#xA;  e[tval[1]] = tval[2];&#xA; end  --]]&#xA;  end&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return ' Экспортирование(унифицированная процедура) в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA; --//       TrrFile -- файл отчета тарировки&#xA; --//       NewTrr -- источник данных XML файл метрологии&#xA; --//       'ReportInclT1.ods' -- шаблон в Devices&#xA; --//       'ReportInclT1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  -- из файла метрологии&#xA;  ExportToCalc('ReportInclT.ods', 'ReportInclT.xml', TrrFile, NewTrr);&#xA;end&#xA;"/>
			</InclTem1>
		</TRR_MODEL>
	</InclinT>
	<AccelT SETUP_METR="--begin&#xA;--//  тип создание ветви поправкок и заполнение значениями по умолчанию&#xA;--// косоугольность, смещение 0 амплит. акселер.&#xA; -- AddXmlPath(t, 'accel');&#xA;--  AddXmlMatrix(t.accel, 3,4);&#xA;--// по умолранию амплит=1 остальнвые 0&#xA;--  t.accel.m3x4.m11 = 1;&#xA;--  t.accel.m3x4.m22 = 1;&#xA;--  t.accel.m3x4.m33 = 1;&#xA; -- AddXmlVect3D_T(t.accel);&#xA;--// косоугольность, смещение 0 амплит. магнит.&#xA;--  AddXmlPath(t, 'magnit');&#xA;--  AddXmlMatrix(t.magnit, 3,4);&#xA;--// по умолранию амплит=1 остальнвые 0&#xA;--  t.magnit.m3x4.m11 = 1;&#xA;--  t.magnit.m3x4.m22 = 1;&#xA; -- t.magnit.m3x4.m33 = 1;&#xA; -- AddXmlVect3D_T(t.magnit);&#xA;--end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<AC_T EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; --var&#xA;  --os,oc,zs,zc,&#xA;--  a, zu, o, mo, b,&#xA;--  x,y,z, Hx, Hy, Hz: Double;&#xA;--  res: Variant;&#xA;--begin&#xA;--// получение тарированных данных&#xA;--// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;--// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;--// - четвертая размерность V[4].ROW=1&#xA;--// ROW- атрибут сырые данные с прибора&#xA; -- local tem = v.T.DEV.VALUE &#xA;--  local x,y,z = TrrVect3D_T(t.accel.T, v.accel, tem);--//, 1000);&#xA;--  local x,y,z = TrrVect3D_T(t.magnit.T, v.magnit, tem);--//, 1000);&#xA;--end;&#xA;  local i, dat, acc;&#xA;  i = 1;&#xA;  &#xA;  dat = v['Accel'..i];&#xA;  acc = dat.accel;&#xA;&#xA;  x = acc.X.DEV.VALUE;&#xA;  y = acc.Y.DEV.VALUE;&#xA;  z = acc.Z.DEV.VALUE;&#xA;&#xA;-- TODO find clc&#xA;  x = x*t.accel1.EE_kA1 + t.accel1.EE_dA1; &#xA;&#xA;  acc.X.CLC.VALUE = x;&#xA;  acc.Y.CLC.VALUE = y;&#xA;  acc.Z.CLC.VALUE = z;&#xA;&#xA;  o = ArcTan2(y, -x);&#xA;  zu = ArcTan2(Hypot(x, y), z);&#xA;&#xA;  dat['отклонитель'].CLC.VALUE = RadToDeg360(o);&#xA;  dat['зенит'].CLC.VALUE       = RadToDeg180(zu);&#xA;  dat['амплит_accel'].CLC.VALUE = Hypot3D(x, y, z);--]]&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;--// Форматирование accel&#xA;  local m,i;&#xA; i = 1;&#xA;  m = AddMetrology(v['Accel'..i].accel.X.DEV, 'ax', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x808F0000, 1, 1);&#xA;  m = AddMetrology(v['Accel'..i].accel.Y.DEV, 'ay', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x80008F00, 1, 1);&#xA;  m = AddMetrology(v['Accel'..i].accel.Z.DEV, 'az', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, 0x8000008F, 1, 1);&#xA;&#xA;--// вычисляемые параметры accel&#xA;  m = AddMetrology(v['Accel'..i].accel.X, 'AX', 'mG');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFFFF0000, 3, 1);&#xA;  m = AddMetrology(v['Accel'..i].accel.Y, 'AY', 'mG');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF00FF00, 3, 1);&#xA;  m = AddMetrology(v['Accel'..i].accel.Z, 'AZ', 'mG');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, 0xFF0000FF, 3, 1);&#xA;&#xA;  m = AddMetrology(v['Accel'..i].T.DEV, 'темпр', '°C');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -40, 150);&#xA;  AddMetrologyCL(m, 0x80004080, 2, 3);&#xA;&#xA;--  // вычисляемые параметры&#xA;--  //AddXmlPath(v, 'зенит');&#xA;  v['Accel'..i]['зенит'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['Accel'..i]['зенит'], 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0800080, 2, 2);&#xA;  m = AddMetrology(v['Accel'..i]['зенит'].DEV, 'zen', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;&#xA;  --//AddXmlPath(v, 'отклонитель');&#xA;  v['Accel'..i]['отклонитель'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['Accel'..i]['отклонитель'], 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0404000, 2, 1);&#xA;  m = AddMetrology(v['Accel'..i]['отклонитель'].DEV, 'viz', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;&#xA;--  //AddXmlPath(v, 'амплит_accel');&#xA;  m = AddMetrology(v['Accel'..i]['амплит_accel'], 'A', 'mG');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 2000);&#xA;  AddMetrologyCL(m, 0xC0408000, 2, 2);&#xA;  m = AddMetrology(v['Accel'..i]['амплит_accel'].DEV, 'dev.A', 'mG');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;--end;&#xA;  local acc;&#xA;&#xA;  acc = AddXmlPath(t, 'accel1');&#xA;  SetIfNotExist(acc, 'EE_dA1' , 0.1);&#xA;  SetIfNotExist(acc, 'EE_kA1' , 1);&#xA;  --acc.EE_dA1 = 0.1;&#xA;  --acc.EE_kA1 = 1;&#xA;  --local acc1da1,acc1ka1;&#xA;  --acc1da1 = AddXmlPath(t, 'accel1.EE_dA1.DEV');&#xA;  --acc1ka1 = AddXmlPath(t, 'accel1.EE_kA1.DEV');&#xA;--// по умолранию амплит=1 остальнвые 0&#xA;  --acc1da1.VALUE = 1.1;&#xA;  --acc1ka1.VALUE = 1;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</AC_T>
		</MODEL>
		<TRR_MODEL>
			<AccelTem1 SETUP_METR="local W ={&#xA;  {1, 'Gz1=Gz2=Gz3=Gz4=Gz5=max', {{'Zenit_Stol',0}, {'Azimut_Stol',0}}},&#xA;  {2, 'Hz1=Hz2=Hz3=Hz4=Hz5=max', {{'Zenit_StolPA',0}}},&#xA;  {3, 'Gx1=Gx5=max; Gx3=min; Gy2=min;Gy4=max.', {{'Vizir_Stol',0}, {'Azimut_Stol',90}, {'Zenit_Stol',90}}},&#xA;  {4, 'Hx1=Hy1=Hx5=Hy5=max; Hx3=Hx3=min', {{'Vizir_StolPA',0}}},&#xA;  {5, 'Gy1=Gy5=min; Gy3=max; Gx2=min;Gx4=max', {{'Vizir_Stol',90}}},&#xA;  {6, 'Hx2=Hy2=max; Hx4=Hy4=min', {{'Vizir_StolPA',90}}},&#xA;  {7, 'Gx1=Gx5=min; Gx3=max; Gy2=max;Gy4=min', {{'Vizir_Stol',180}}},&#xA;  {8, 'Hx1=Hy1=Hx5=Hy5=min; Hx3=Hx3=max', {{'Vizir_StolPA',180}}},&#xA;  {9, 'Gy1=Gy5=max;Gy3=min;Gx2=max;Gx4=min', {{'Vizir_Stol',270}}},&#xA;  {10, 'Hx2=Hy2=min; Hx4=Hy4=max', {{'Vizir_StolPA',270}}},&#xA;  {11, 'Gz1=Gz2=Gz3=Gz4=Gz5=min', {{'Azimut_Stol',0}, {'Zenit_Stol',180}}},&#xA;  {12, 'Hz1=Hz2=Hz3=Hz4=Hz5=min',  {{'Zenit_StolPA',180}}},&#xA;  &#xA;  {13, 'ЗУ=90', {{'Zenit_Stol',90}}},&#xA;  {14, 'Нагрев до 125 градусов', {{'Temp_Nagr', 125}}},&#xA;  &#xA;  {15, 'Gz1=Gz2=Gz3=Gz4=Gz5=max', {{'Zenit_Stol',0}}},&#xA;  {16, 'Hz1=Hz2=Hz3=Hz4=Hz5=max', {{'Zenit_StolPA',0}}},&#xA;  {17, 'Hx2=Hy2=min; Hx4=Hy4=max', {{'Azimut_Stol',90}, {'Zenit_Stol',90}}},&#xA;  {18, 'Gy1=Gy5=max;Gy3=min;Gx2=max;Gx4=min', {{'Vizir_Stol',270}}},&#xA;  {19, 'Hx1=Hy1=Hx5=Hy5=min; Hx3=Hx3=max', {{'Vizir_StolPA',180}}},&#xA;  {20, 'Gx1=Gx5=min; Gx3=max; Gy2=max;Gy4=min', {{'Vizir_Stol',180}}},&#xA;  {21, 'Hx2=Hy2=max; Hx4=Hy4=min', {{'Vizir_StolPA',90}}},&#xA;  {22, 'Gy1=Gy5=min; Gy3=max; Gx2=min;Gx4=max', {{'Vizir_Stol',90}}},&#xA;  {23, 'Hx1=Hy1=Hx5=Hy5=max; Hx3=Hx3=min', {{'Vizir_StolPA',0}}},&#xA;  {24, 'Gx1=Gx5=max; Gx3=min; Gy2=min;Gy4=max.', {{'Vizir_Stol',0}}},&#xA;  {25, 'Gz1=Gz2=Gz3=Gz4=Gz5=min', {{'Azimut_Stol',0}, {'Zenit_Stol',180}}},&#xA;  {26, 'Hz1=Hz2=Hz3=Hz4=Hz5=min',  {{'Zenit_StolPA',180}}},&#xA;&#xA;  {27, 'ЗУ=90', {{'Zenit_Stol',90}}},&#xA;  {28, 'Остывание до 100 градусов', {{'Temp_Ost', 100}}},&#xA;  &#xA;  {29, 'Gz1=Gz2=Gz3=Gz4=Gz5=max', {{'Zenit_Stol',0}}},&#xA;  {30, 'Hz1=Hz2=Hz3=Hz4=Hz5=max', {{'Zenit_StolPA',0}}},&#xA;  {31, 'Gx1=Gx5=max; Gx3=min; Gy2=min;Gy4=max.', {{'Azimut_Stol',90}, {'Zenit_Stol',90}}},&#xA;  {32, 'Hx1=Hy1=Hx5=Hy5=max; Hx3=Hx3=min', {{'Vizir_StolPA',0}}},&#xA;  {33, 'Gy1=Gy5=min; Gy3=max; Gx2=min;Gx4=max', {{'Vizir_Stol',90}}},&#xA;  {34, 'Hx2=Hy2=max; Hx4=Hy4=min', {{'Vizir_StolPA',90}}},&#xA;  {35, 'Gx1=Gx5=min; Gx3=max; Gy2=max;Gy4=min', {{'Vizir_Stol',180}}},&#xA;  {36, 'Hx1=Hy1=Hx5=Hy5=min; Hx3=Hx3=max', {{'Vizir_StolPA',180}}},&#xA;  {37, 'Gy1=Gy5=max;Gy3=min;Gx2=max;Gx4=min', {{'Vizir_Stol',270}}},&#xA;  {38, 'Hx2=Hy2=min; Hx4=Hy4=max', {{'Vizir_StolPA',270}}},&#xA;  {39, 'Gz1=Gz2=Gz3=Gz4=Gz5=min', {{'Azimut_Stol',0}, {'Zenit_Stol',180}}},&#xA;  {40, 'Hz1=Hz2=Hz3=Hz4=Hz5=min',  {{'Zenit_StolPA',180}}},&#xA;&#xA;  {41, 'Остывание до 32 градусов &quot;Измерения проводятся на следующий день&quot; ', {{'Temp_Ost', 32}}},&#xA;&#xA;  {42, 'Hz1=Hz2=Hz3=Hz4=Hz5=min',{}},&#xA;  {43, 'Gz1=Gz2=Gz3=Gz4=Gz5=min', {{'Zenit_Stol',180}}},&#xA;  {44, 'Hx2=Hy2=min; Hx4=Hy4=max',{{'Azimut_Stol',90}, {'Zenit_Stol',90}}},&#xA;  {45, 'Gy1=Gy5=max;Gy3=min;Gx2=max;Gx4=min', {{'Vizir_Stol',270}}},&#xA;  {46, 'Hx1=Hy1=Hx5=Hy5=min; Hx3=Hx3=max', {{'Vizir_StolPA',180}}},&#xA;  {47, 'Gx1=Gx5=min; Gx3=max; Gy2=max;Gy4=min', {{'Vizir_Stol',180}}}, &#xA;  {48, 'Hx2=Hy2=max; Hx4=Hy4=min', {{'Vizir_StolPA',90}}},&#xA;  {49, 'Gy1=Gy5=min; Gy3=max; Gx2=min;Gx4=max', {{'Vizir_Stol',90}}}, &#xA;  {50, 'Hx1=Hy1=Hx5=Hy5=max; Hx3=Hx3=min', {{'Vizir_StolPA',0}}},&#xA;  {51, 'Gx1=Gx5=max; Gx3=min; Gy2=min;Gy4=max.', {{'Vizir_Stol',0}}},&#xA;  {52, 'Hz1=Hz2=Hz3=Hz4=Hz5=max', {{'Zenit_StolPA',0},{'Azimut_Stol',0}}},&#xA;  {53, 'Gz1=Gz2=Gz3=Gz4=Gz5=min', {{'Zenit_Stol',0}}},&#xA;&#xA;};&#xA;&#xA;  findHG = function (stp, root)&#xA;    local s = AddXmlPath(stp, root);&#xA;    AddXmlPath(s, 'X.DEV');&#xA;    AddXmlPath(s, 'Y.DEV');&#xA;    AddXmlPath(s, 'Z.DEV');&#xA;    s.X.DEV.VALUE = 0;&#xA;    s.Y.DEV.VALUE = 0;&#xA;    s.Z.DEV.VALUE = 0;   &#xA;  end&#xA;&#xA;  for key, val in next, W do&#xA;--   begin&#xA;   local s = AddXmlPath(t, 'STEP'..key);&#xA;    s.EXECUTED = false;&#xA;    s.STEP = val[1];&#xA;    s.INFO = val[2];&#xA;    for i = 1, 5 do &#xA;  findHG(s, 'Inclin'..i..'.accel');&#xA;  findHG(s, 'Inclin'..i..'.magnit');&#xA;        local tmp = AddXmlPath(s, 'Inclin'..i..'.T.DEV');&#xA;        tmp.VALUE = 0;&#xA;    end&#xA;    local e = AddXmlPath(s,'TASK');&#xA;    for tkey, tval in next, val[3] do&#xA;  e[tval[1]] = tval[2];&#xA; end  --]]&#xA;  end&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return ' Экспортирование(унифицированная процедура) в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA; --//       TrrFile -- файл отчета тарировки&#xA; --//       NewTrr -- источник данных XML файл метрологии&#xA; --//       'ReportInclT1.ods' -- шаблон в Devices&#xA; --//       'ReportInclT1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  -- из файла метрологии&#xA;  ExportToCalc('ReportInclT.ods', 'ReportInclT.xml', TrrFile, NewTrr);&#xA;end&#xA;"/>
			</AccelTem1>
		</TRR_MODEL>
	</AccelT>
	<accel SETUP_METR=" &#xA; --AddXmlPath(t, 'accel');&#xA;&#xA; if AddXmlMatrix(t, 3,4) then -- реально добавлены&#xA;-- т.к. скрипт выполняется дважды для WRK b RAM&#xA;--// по умолранию амплит=1 остальнвые 0&#xA;-- &#xA;  t.m3x4.m11 = 1;&#xA;  t.m3x4.m22 = 1;&#xA;  t.m3x4.m33 = 1;&#xA; end&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<CLA1 EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; --var&#xA;--  os,oc,zs,zc,&#xA;--  a, zu, o, mo, b,&#xA;--  x,y,z, Hx, Hy, Hz: Double;&#xA;--  res: Variant;&#xA;--begin&#xA;--// получение тарированных данных&#xA;--// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;--// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;--// - четвертая размерность V[4].ROW=1&#xA;--// ROW- атрибут сырые данные с прибора&#xA;--//  TrrVect3D(t.accel.m3x4, v.accel);//, 1000);&#xA;  v.X.CLC.VALUE = v.X.DEV.VALUE*2000/0x8000;&#xA;  v.Y.CLC.VALUE = v.Y.DEV.VALUE*2000/0x8000;&#xA;  v.Z.CLC.VALUE = v.Z.DEV.VALUE*2000/0x8000;&#xA;&#xA;  x = v.X.CLC.VALUE;&#xA;  y = v.Y.CLC.VALUE;&#xA;  z = v.Z.CLC.VALUE;&#xA;&#xA;  v['амплит_accel'].CLC.VALUE = Hypot3D(x, y, z);&#xA;&#xA;  o = ArcTan2(y, -x);&#xA;  zu = ArcTan2(Hypot(x, y), z);&#xA;--   o = ArcTan2(-z, x);&#xA;--   zu = ArcTan2(Hypot(-x, -z), -y);&#xA;&#xA;  v['зенит'].CLC.VALUE       = RadToDeg180(zu);&#xA;  v['отклонитель'].CLC.VALUE = RadToDeg360(o);&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m = AddMetrology(v.X, 'AX', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0xFFFF0000, 3, 1);&#xA;&#xA;  m = AddMetrology(v.Y, 'AY', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0xFF00FF00, 3, 1);&#xA;&#xA;  m = AddMetrology(v.Z, 'AZ', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0xFF0000FF, 3, 1);&#xA;&#xA;  m = AddMetrology(v.X.DEV, 'ax', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -0x8000, 0x8000);&#xA;  AddMetrologyCL(m, 0x808F0000, 1, 1);&#xA;  m = AddMetrology(v.Y.DEV, 'ay', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -0x8000, 0x8000);&#xA;  AddMetrologyCL(m, 0x80008F00, 1, 1);&#xA;  m = AddMetrology(v.Z.DEV, 'az', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -0x8000, 0x8000);&#xA;  AddMetrologyCL(m, 0x8000008F, 1, 1);&#xA;&#xA;--  // вычисляемые параметры&#xA;  AddXmlPath(v, 'зенит');&#xA;  v['зенит'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['зенит'], 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0800080, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'отклонитель');&#xA;  v['отклонитель'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['отклонитель'], 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0404000, 2, 1);&#xA;&#xA;  AddXmlPath(v, 'амплит_accel');&#xA;  m = AddMetrology(v['амплит_accel'], 'A', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, 0xC0408000, 2, 2);&#xA;&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</CLA1>
			<AGA1 EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; --var&#xA;--  os,oc,zs,zc,&#xA;--  a, zu, o, mo, b,&#xA;--  x,y,z, Hx, Hy, Hz: Double;&#xA;--  res: Variant;&#xA;--begin&#xA;--// получение тарированных данных&#xA;--// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;--// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;--// - четвертая размерность V[4].ROW=1&#xA;--// ROW- атрибут сырые данные с прибора&#xA; --DebugLog('BEGIN TrrVect3D(t.m3x4, v.accel);')&#xA; local x,y,z = TrrVect3D(t.m3x4, v);&#xA; --DebugLog('END TrrVect3D(t.m3x4, v.accel);')&#xA;&#xA;  v['амплит_accel'].CLC.VALUE = Hypot3D(x, y, z);&#xA;&#xA;  o = ArcTan2(y, -x);&#xA;  zu = ArcTan2(Hypot(x, y), z);&#xA;&#xA;  v['зенит'].CLC.VALUE       = RadToDeg180(zu);&#xA;  v['отклонитель'].CLC.VALUE = RadToDeg360(o);--]]&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m = AddMetrology(v.X, 'AX', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0xFFFF0000, 3, 1);&#xA;&#xA;  m = AddMetrology(v.Y, 'AY', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0xFF00FF00, 3, 1);&#xA;&#xA;  m = AddMetrology(v.Z, 'AZ', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0xFF0000FF, 3, 1);&#xA;&#xA;  m = AddMetrology(v.X.DEV, 'ax', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x808F0000, 1, 1);&#xA;  m = AddMetrology(v.Y.DEV, 'ay', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x80008F00, 1, 1);&#xA;  m = AddMetrology(v.Z.DEV, 'az', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, 0x8000008F, 1, 1);&#xA;&#xA;--  // вычисляемые параметры&#xA;  AddXmlPath(v, 'зенит');&#xA;  v['зенит'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['зенит'], 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0800080, 2, 2);&#xA;&#xA;  m = AddMetrology(v['зенит'].DEV, 'прб_зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;&#xA;  AddXmlPath(v, 'отклонитель');&#xA;  v['отклонитель'].METR = 'ANGLE';&#xA;  m = AddMetrology(v['отклонитель'], 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xC0404000, 2, 1);&#xA;&#xA;  m = AddMetrology(v['отклонитель'].DEV, 'прб_визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;&#xA;  AddXmlPath(v, 'амплит_accel');&#xA;  m = AddMetrology(v['амплит_accel'], 'A', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, 0xC0408000, 2, 2);--]]&#xA;&#xA;  m = AddMetrology(v['амплит_accel'].DEV, 'прб_A', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</AGA1>
		</MODEL>
		<TRR_MODEL>
			<ACL14>
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return ' Unif Экспортирование в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA; --//       TrrFile -- файл тарировки&#xA; --//       NewTrr -- источник данных&#xA; --//       'ReportNNK1.ods' -- шаблон в Devices&#xA; --//       'ReportNNK1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  ExportToCalc('ReportACCEL.ods', 'ReportACCEL.xml', TrrFile, NewTrr);&#xA;end&#xA;" EXPORT1="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в печать диаграмм(*.inc)|*.inc';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;&#xA;  ExportToIncAccel( TrrFile, NewTrr);&#xA;end&#xA;"/>
			</ACL14>
		</TRR_MODEL>
	</accel>
	<ИКН SETUP_METR="--begin&#xA;  Setup_IKN(t);&#xA;--//  тип создание ветви поправкок и заполнение значениями по умолчанию&#xA;--// косоугольность, смещение 0 амплит. акселер.&#xA;--//  AddXmlPath(t, 'accel');&#xA;--//  AddXmlMatrix(t.accel, 3,4);&#xA;--// по умолранию амплит=1 остальнвые 0&#xA;--//  t.accel.m3x4.m11 := 1;&#xA;--//  t.accel.m3x4.m22 := 1;&#xA;--//  t.accel.m3x4.m33 := 1;&#xA;--// косоугольность, смещение 0 амплит. магнит.&#xA;--//  AddXmlPath(t, 'magnit');&#xA;--//  AddXmlMatrix(t.magnit, 3,4);&#xA;--// по умолранию амплит=1 остальнвые 0&#xA;--//  t.magnit.m3x4.m11 := 1;&#xA;--//  t.magnit.m3x4.m22 := 1;&#xA;--//  t.magnit.m3x4.m33 := 1;&#xA;--end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<A2 EXEC_METR="Exec_IKN_A2(v, t);&#xA;" SETUP_METR="Setup_IKN_A2(v);&#xA;&#xA;">
				<IMPORT IMPORT0="function GetFilterName()&#xA;&#xA;  return 'Импортирование из Cal (*.Cal)|*.Cal';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  Import_IKN_A2(TrrFile, NewTrr);&#xA;end&#xA;"/>
				<EXPORT/>
			</A2>
		</MODEL>
		<TRR_MODEL/>
	</ИКН>
	<ГК SETUP_METR="--{ procedure (v, t, run_path, run_address: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;-- run_path -WRK, RAM&#xA;-- run_address - adres modulia&#xA;&#xA;--begin&#xA;--[[if not GK_Setup_Exist then&#xA;  GK_Setup_Exist = true;&#xA;  t.kGK = 1;&#xA;  DebugLog('Гк установки', 'params:', run_path, run_address);&#xA;else&#xA;  DebugLog('Гк установки REPEAT', 'params:', run_path, run_address);&#xA;end;--]]&#xA;&#xA;SetIfNotExist(t, 'kGK' , 1);&#xA;--end;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<GK1 EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;--//  SGK_FindGK(v);&#xA;  v['гк'].CLC.VALUE =  t.kGK * v['гк'].DEV.VALUE;&#xA;--end;&#xA;&#xA;--DebugLog('Гк GK1 выполнение', 'params:', run_path, run_address, t.kGK, v['гк'].DEV.VALUE);&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m = AddMetrology(v['гк'], 'гк', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;--//  AddMetrology(v.гк, 'мкР/ч', '%8.1f',  0, 200);&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</GK1>
			<GK_SGK EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  SGK_FindGK(v);&#xA;  v['гк'].CLC.VALUE =  t.kGK * v['гк'].DEV.VALUE;&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m = AddMetrology(v['гк'], 'гк', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;--//  AddMetrology(v.гк, 'мкР/ч', '%8.1f',  0, 200);&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</GK_SGK>
		</MODEL>
		<TRR_MODEL>
			<TGK EXEC_METR="function execute_step(stp, alg, trr)&#xA;-- var&#xA;--  st: variant;&#xA;--  a, Dz: Double;&#xA;--begin&#xA;  if alg.STEP7['гк'].DEV.VALUE ~= alg.STEP3['гк'].DEV.VALUE then&#xA;       trr.kGK = 40/(alg.STEP7['гк'].DEV.VALUE - alg.STEP3['гк'].DEV.VALUE);&#xA;  end&#xA;&#xA;  a = trr.kGK;&#xA;&#xA;  Dz = alg.STEP1['гк'].DEV.VALUE * a;&#xA;&#xA;  trr.Delta = alg.STEP1['гк'].DEV.VALUE;&#xA;&#xA;  if stp == 1 then &#xA;     alg.STEP1['гк'].CLC.VALUE = Dz&#xA;  else   &#xA;    st = AddXmlPath(alg, 'STEP'..stp);&#xA;    st['гк'].CLC.VALUE = st['гк'].DEV.VALUE * a - Dz;&#xA;    st.DELTA = (st['гк'].CLC.VALUE - st.RT)*100/st.RT;&#xA;   end&#xA;end&#xA;" SETUP_METR="-- var&#xA;--  i: Integer;&#xA;--  s, d, e: Variant;&#xA;--begin&#xA;  local i, s, d, e;&#xA;  local GC ={'P0_HOME', 'P5_HOME', 'P10', 'P20', 'P30', 'P40', 'P50', 'P100', 'P150', 'P200'};&#xA;  local RT1 ={0, 5, 10, 20, 30, 40, 50, 100, 150, 200};&#xA;  local INF ={'1) фон 0.','2) - 5','3) 3.095 10','4) 2.188 20','5) 1.787 30','6) 1.547 40','7) 1.384 50','8) 0.979 100','9) 0.799 150','10) 0.692 200'};&#xA;&#xA;  for i = 1, 10 do&#xA;--   begin&#xA;    s = AddXmlPath(t, 'STEP'..i);&#xA;    s.EXECUTED = false;&#xA;    s.STEP = i;&#xA;    s.DELTA = 0;&#xA;    s.RT = RT1[i];&#xA;    s.INFO = INF[i]; &#xA;    d = AddXmlPath(s,'гк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE = 0;&#xA;    d.DEV.VALUE = 0;&#xA;    e = AddXmlPath(s,'TASK');&#xA;    e.Gk_Stol = GC[i];&#xA;   end&#xA;&#xA; t.STEP1.ATT_COUNT = 40;&#xA; t.STEP3.ATT_COUNT = 40;&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportGKToCalc(TrrFile, NewTrr, 'GK');&#xA;end&#xA;" EXPORT1="function GetFilterName()&#xA;&#xA;  return ' Unif Экспортирование в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA; --//       TrrFile -- файл тарировки&#xA; --//       NewTrr -- источник данных&#xA; --//       'ReportNNK1.ods' -- шаблон в Devices&#xA; --//       'ReportNNK1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  ExportToCalc('ReportGK.ods', 'ReportGK.xml', TrrFile, NewTrr);&#xA;end&#xA;"/>
			</TGK>
			<TGK_LS EXEC_METR="function execute_step(stp, alg, trr)&#xA;  ExecStepGK1(stp, alg, trr, true);&#xA;end;&#xA;" SETUP_METR="-- var&#xA;--  i: Integer;&#xA;--  s, d, e: Variant;&#xA;--begin&#xA;  for i = 1, 10 do&#xA;--   begin&#xA;    s = AddXmlPath(t, 'STEP'..i);&#xA;    s.EXECUTED = False;&#xA;    s.STEP = i;&#xA;    s.DELTA = 0;&#xA;    d = AddXmlPath(s,'гк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE = 0;&#xA;    d.DEV.VALUE = 0;&#xA;    e = AddXmlPath(s,'TASK');&#xA;   end&#xA;&#xA; t.STEP1.ATT_COUNT = 40;&#xA;--// t.STEP2.ATT_COUNT := 30;&#xA; t.STEP3.ATT_COUNT = 40;&#xA;--// t.STEP4.ATT_COUNT := 30;&#xA;--// t.STEP5.ATT_COUNT := 30;&#xA;--// t.STEP6.ATT_COUNT := 30;&#xA;--// t.STEP7.ATT_COUNT := 40;&#xA;--// t.STEP8.ATT_COUNT := 30;&#xA;--// t.STEP9.ATT_COUNT := 30;&#xA;--// t.STEP10.ATT_COUNT := 30;&#xA;&#xA;&#xA; t.STEP1.TASK.Gk_Stol = 'P0_HOME';&#xA; t.STEP2.TASK.Gk_Stol = 'P5_HOME';&#xA; t.STEP3.TASK.Gk_Stol = 'P10';&#xA; t.STEP4.TASK.Gk_Stol = 'P20';&#xA; t.STEP5.TASK.Gk_Stol = 'P30';&#xA; t.STEP6.TASK.Gk_Stol = 'P40';&#xA; t.STEP7.TASK.Gk_Stol = 'P50';&#xA; t.STEP8.TASK.Gk_Stol = 'P100';&#xA; t.STEP9.TASK.Gk_Stol = 'P150';&#xA; t.STEP10.TASK.Gk_Stol = 'P200';&#xA;&#xA; t.STEP1.RT = 0;&#xA; t.STEP2.RT = 5;&#xA; t.STEP3.RT = 10;&#xA; t.STEP4.RT = 20;&#xA; t.STEP5.RT = 30;&#xA; t.STEP6.RT = 40;&#xA; t.STEP7.RT = 50;&#xA; t.STEP8.RT = 100;&#xA; t.STEP9.RT = 150;&#xA; t.STEP10.RT = 200;&#xA;&#xA; t.STEP1.INFO = '1) фон 0.';&#xA; t.STEP2.INFO = '2) - 5';&#xA; t.STEP3.INFO = '3) 3.095 10';&#xA; t.STEP4.INFO = '4) 2.188 20';&#xA; t.STEP5.INFO = '5) 1.787 30';&#xA; t.STEP6.INFO = '6) 1.547 40';&#xA; t.STEP7.INFO = '7) 1.384 50';&#xA; t.STEP8.INFO = '8) 0.979 100';&#xA; t.STEP9.INFO = '9) 0.799 150';&#xA; t.STEP10.INFO = '10) 0.692 200';&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportGKToCalc(TrrFile, NewTrr, 'GK');&#xA;end&#xA;"/>
			</TGK_LS>
		</TRR_MODEL>
	</ГК>
	<ГГКП SETUP_METR="--{ procedure (v, t, run_path, run_address: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;-- run_path -WRK, RAM&#xA;-- run_address - adres modulia&#xA;&#xA;--begin&#xA; if not HasXmlPath(t, 'D1') then &#xA;  AddXmlPath(t, 'D1');&#xA;  AddXmlPath(t, 'D2');&#xA;  AddXmlPath(t, 'D3');&#xA;  t.C1 = 3.5;&#xA;  t.D1.D =  156;&#xA;  t.D1.x = -0.6;&#xA;  t.D1.y =  0.9;&#xA;  t.D2.D =  216;&#xA;  t.D2.x = -0.7;&#xA;  t.D2.y =  0.8;&#xA;  t.D3.D =  295;&#xA;  t.D3.x = -0.8;&#xA;  t.D3.y =  0.7;&#xA; -- DebugLog('GGKP установки', 'params:', run_path, run_address);&#xA; end--]]&#xA;--end;&#xA;"><IMPORT/>
		<EXPORT/>
		<MODEL>
			<GGKP1 EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  local x, y, D;&#xA;   x = t.D1.x;&#xA;   y = t.D1.y;&#xA;   &#xA;  D = GetProjectOption('DIAM');&#xA;  &#xA;  &#xA;  local Lin = function (x1,x2,y1,y2, d)&#xA;    local k, b;&#xA;    k = (y2-y1)/(x2-x1);&#xA;    b = y1 - k*x1;&#xA;    return k*d + b;&#xA;  end;&#xA;&#xA;  if D then&#xA;   if D &lt; t.D2.D then&#xA;    x = Lin(t.D1.D, t.D2.D, t.D1.x, t.D2.x, D);&#xA;    y = Lin(t.D1.D, t.D2.D, t.D1.y, t.D2.y, D);&#xA;   else &#xA;    x = Lin(t.D2.D, t.D3.D, t.D2.x, t.D3.x, D);&#xA;    y = Lin(t.D2.D, t.D3.D, t.D2.y, t.D3.y, D);&#xA;   end;&#xA;  end;&#xA;&#xA; --DebugLog('D X Y', D, x, y);&#xA;&#xA;  if (v['гк1'].DEV.VALUE &gt; 0) and (v['гк2'].DEV.VALUE &gt; 0) then&#xA;    v['Плотность'].CLC.VALUE = x*math.log(t.C1*v['гк2'].DEV.VALUE/v['гк1'].DEV.VALUE) + y;&#xA;  else&#xA;    v['Плотность'].CLC.VALUE = 0;&#xA;  end --]]&#xA;--end;&#xA;&#xA;--DebugLog('Гк GK1 выполнение', 'params:', run_path, run_address, t.kGK, v['гк'].DEV.VALUE);&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;local m;&#xA;--[[  m = AddMetrology(v['гк1'], 'гк1', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['гк2'], 'гк2', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFF7F0000);--]]&#xA;&#xA;  AddXmlPath(v, 'Плотность');&#xA;  m = AddMetrology(v['Плотность'], 'г/см3', ' ', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 10);&#xA;  AddMetrologyCL(m, 0xFF7F007F);--]]&#xA;&#xA;--//  AddMetrology(v.гк, 'мкР/ч', '%8.1f',  0, 200);&#xA;--end;&#xA;&#xA;"><IMPORT/>
				<EXPORT/>
			</GGKP1></MODEL>
		<TRR_MODEL>
			<TGGKP1 EXEC_METR="function execute_step(stp, alg, trr)&#xA;&#xA;  local FindPlot = function (ast)&#xA;   local a1, pt, x, y = {},{}&#xA;   for i,v in ipairs(ast) do&#xA;     local s = alg['STEP'..v];&#xA;     s.A1 = trr.C1*s['гк2'].DEV.VALUE/s['гк1'].DEV.VALUE&#xA;     s.logA1 = math.log(s.A1);&#xA;     a1[i] = s.logA1&#xA;     pt[i] = s.PLOTN&#xA;   end&#xA;   y, x = PolyAprox(a1, pt, 2);&#xA;   for _,v in ipairs(ast) do&#xA;     local s = alg['STEP'..v];&#xA;     s.PlA1 =x*s.logA1 + y;&#xA;     s.Err = (s.PlA1 - s.PLOTN)/s.PLOTN*100;&#xA;   end; &#xA;   return x, y;&#xA;  end;&#xA;&#xA;  if stp == 11 then &#xA;    trr.C1 = alg.STEP1['гк1'].DEV.VALUE/alg.STEP1['гк2'].DEV.VALUE&#xA;    trr.D1.x, trr.D1.y = FindPlot({2,3,4})&#xA;    trr.D2.x, trr.D2.y = FindPlot({5,6,7})&#xA;    trr.D3.x, trr.D3.y = FindPlot({8,9,10})&#xA;--    DebugLog('stp', stp, trr.D1.x, trr.D1.y);&#xA;  end&#xA;end&#xA;" SETUP_METR="-- var&#xA;--  i: Integer;&#xA;--  s, d, e: Variant;&#xA;--begin&#xA;  local i, s, d, e;&#xA;  local PLOTN ={'вода', 2.14, 2.45, 2.698, 2.14, 2.43, 2.698, 2.14, 2.43, 2.698, 'вода'};&#xA;  local DIA ={156, 156, 156, 156, 216, 216, 216, 295, 295, 295, 295};&#xA;  local INF ={'1) Вода.','2) Д156 П2.14','3) Д156 П2.45','4) Д156 П2.698',&#xA;              '5)Д216 П2.14','6) Д216 П2.43','7)  Д216 П2.698',&#xA;              '8) Д295 П2.14','9)  Д295 П2.43','10) Д295 П2.698','11) Вода.'};&#xA;&#xA;  for i = 1, 11 do&#xA;    s = AddXmlPath(t, 'STEP'..i);&#xA;    s.EXECUTED = false;&#xA;    s.STEP = i;&#xA;    s.D = DIA[i];&#xA;    s.logA1 = 0;&#xA;    s.A1 = 0;&#xA;    s.PlA1 = 0;&#xA;    s.Err = 0;&#xA;    s.PLOTN = PLOTN[i];&#xA;    s.INFO = INF[i]; &#xA;    d = AddXmlPath(s,'гк1');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.DEV.VALUE = 0;&#xA;    d = AddXmlPath(s,'гк2');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.DEV.VALUE = 0;&#xA;   end&#xA;   t.STEP1.ATT_COUNT = t.AttCount_Voda;&#xA;   t.STEP11.ATT_COUNT = t.AttCount_Voda;&#xA;--end"><IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return ' Unif Экспортирование в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA; --//       TrrFile -- файл тарировки&#xA; --//       NewTrr -- источник данных&#xA; --//       'ReportNNK1.ods' -- шаблон в Devices&#xA; --//       'ReportNNK1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  ExportToCalc('ReportGGKP1.ods', 'ReportGGKP1.xml', TrrFile, NewTrr);&#xA;end&#xA;"/>
			</TGGKP1></TRR_MODEL>
	</ГГКП><АГК SETUP_METR="--{ procedure (v, t, run_path, run_address: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;-- run_path -WRK, RAM&#xA;-- run_address - adres modulia&#xA;&#xA;--begin&#xA;--[[ if not GK_Setup_Exist then&#xA;  GK_Setup_Exist = true;&#xA;  t.kGK = 1;&#xA;  DebugLog('Гк установки', 'params:', run_path, run_address);&#xA;else&#xA;  DebugLog('Гк установки REPEAT', 'params:', run_path, run_address);&#xA;end;--]]&#xA;&#xA;SetIfNotExist(t, 'kGK1' , 1);&#xA;SetIfNotExist(t, 'kGK2' , 1);&#xA;SetIfNotExist(t, 'kGK3' , 1);&#xA;SetIfNotExist(t, 'kGK4' , 1);&#xA;----end;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<AGGR1 EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;--//  SGK_FindGK(v);&#xA;  v.GR1.CLC.VALUE = t.kGK1 * v.GR1.DEV.VALUE;&#xA;  v.GR2.CLC.VALUE = t.kGK2 * v.GR2.DEV.VALUE;&#xA;  v.GR3.CLC.VALUE = t.kGK3 * v.GR3.DEV.VALUE;&#xA;  v.GR4.CLC.VALUE = t.kGK4 * v.GR4.DEV.VALUE;&#xA;--end;&#xA;&#xA;--DebugLog('Гк GK1 выполнение', 'params:', run_path, run_address, t.kGK, v['гк'].DEV.VALUE);&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;&#xA;  local m = AddMetrology(v.GR1, 'гк1', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;  m = AddMetrology(v.GR2, 'гк2', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;  m = AddMetrology(v.GR3, 'гк3', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;  m = AddMetrology(v.GR4, 'гк4', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;--//  AddMetrology(v.гк, 'мкР/ч', '%8.1f',  0, 200);&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</AGGR1>
		</MODEL>
		<TRR_MODEL>
			<TAGK EXEC_METR="function execute_step(stp, alg, trr)&#xA;-- var&#xA;--  st: variant;&#xA;--  a, Dz: Double;&#xA;--begin&#xA;  --Global_Point1, Global_Point7;&#xA;  if stp == 41 then return end;&#xA;&#xA;  local s = alg['STEP'..stp];&#xA;  local cnl = math.tointeger(s.CHANEL);&#xA;  local pnt = math.tointeger(s.POINT);&#xA;&#xA;  if pnt == 1 then &#xA;	Global_Point1 = s['GR'..cnl].DEV.VALUE &#xA;  elseif pnt == 3 then&#xA;	Global_Point3 = s['GR'..cnl].DEV.VALUE &#xA;  elseif pnt == 7 then&#xA;    Global_Point7 = s['GR'..cnl].DEV.VALUE &#xA;    if Global_Point3 ~= Global_Point7 then&#xA;       trr['kGK'..cnl] = 40/(Global_Point7 - Global_Point3);&#xA;    end&#xA;  end&#xA;    &#xA;  local a = trr['kGK'..cnl];&#xA;&#xA;  --DebugLog('LUA_cnl_point_stp2', cnl, pnt, stp, 'END DATA');&#xA;  local Dz = Global_Point1 * a;&#xA;&#xA;  --trr.Delta = alg.STEP1['гк'].DEV.VALUE;&#xA;&#xA;  if pnt == 1 then &#xA;     s['GR'..cnl].CLC.VALUE = Dz&#xA;  else   &#xA;    s['GR'..cnl].CLC.VALUE = s['GR'..cnl].DEV.VALUE * a - Dz;&#xA;    s.DELTA = (s['GR'..cnl].CLC.VALUE - s.RT)*100/s.RT;&#xA;   end&#xA; -- DebugLog('LUA_cnl_point_stp3', cnl, pnt, stp, 'END DATA');&#xA;end&#xA;" SETUP_METR="-- var&#xA;  local GC ={'P0_HOME', 'P5_HOME', 'P10', 'P20', 'P30', 'P40', 'P50', 'P100', 'P150', 'P200', 'P0_HOME'};&#xA;  local RT1 ={0, 5, 10, 20, 30, 40, 50, 100, 150, 200, '-'};&#xA;  local INF ={'фон 0','5','3.095 10','2.188 20','1.787 30','1.547 40','1.384 50','0.979 100','0.799 150','0.692 200', 'Стор'};    &#xA;  local InitStep = function (stp, cnl, point)&#xA;    local s = AddXmlPath(t, 'STEP'..stp);&#xA;    s.EXECUTED = false;&#xA;    s.STEP = stp;&#xA;    s.CHANEL = cnl;&#xA;    s.POINT = point;&#xA;    s.DELTA = 0;&#xA;    s.RT = RT1[point];&#xA;    s.INFO = 'Шаг:'..stp..' Канал: '..cnl..' Точкка: ['..INF[point]..']'; &#xA;    local k;&#xA;    for k = 1, 4 do&#xA;		local d = AddXmlPath(s,'GR'..k);&#xA;		AddXmlPath(d,'CLC');&#xA;		AddXmlPath(d,'DEV');&#xA;		d.CLC.VALUE = 0;&#xA;		d.DEV.VALUE = 0;&#xA;    end&#xA;    local e = AddXmlPath(s,'TASK');&#xA;    e.Gk_Stol = GC[point];&#xA;    return s;&#xA;  end&#xA;--begin&#xA;  local i, j;&#xA;  for j = 1, 4 do&#xA;  for i = 1, 10 do&#xA;    local s = InitStep(i+(j-1)*10, j, i); &#xA;    if (i == 1) or (i == 3) then s.ATT_COUNT = 40 end&#xA;   end&#xA;  end&#xA;  InitStep(41, '-', 11); &#xA;  t.STEP41.ATT_COUNT = 1;&#xA;--end&#xA;&#xA;   ">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return ' Unif Экспортирование в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA; --//       TrrFile -- файл тарировки&#xA; --//       NewTrr -- источник данных&#xA; --//       'ReportNNK1.ods' -- шаблон в Devices&#xA; --//       'ReportNNK1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  ExportToCalc('ReportAGK1.ods', 'ReportAGK1.xml', TrrFile, NewTrr);&#xA;end&#xA;"/>
			</TAGK>
		</TRR_MODEL>
	</АГК>
	<Глубиномер SETUP_METR="--begin&#xA; --// t.kGK := 1;&#xA;--end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<RP45 EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  v['ДлинаТроса'].CLC.VALUE = 0.018686833 * v['ДлинаТроса'].DEV.VALUE;&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: Variant;&#xA;--begin&#xA;  m = AddMetrology(v['ДлинаТроса'], 'Трос', 'см.');&#xA;  AddMetrologyFM(m, 4, 2);&#xA;  AddMetrologyRG(m, 0, 4500);&#xA;  AddMetrologyCL(m, 0xFF008080, 3, 1);&#xA;--  // вычисляемые параметры&#xA;  AddXmlPath(v, 'Глубина');&#xA;  m = AddMetrology(v['Глубина'], 'Глубина', 'м.');&#xA;  AddMetrologyFM(m, 4, 2);&#xA;  AddMetrologyCL(m, 0xFF8080F0, 2, 1);&#xA;  m = AddMetrology(v['Нагрузка'].DEV, 'Нагрузка', 'уе.');&#xA;  AddMetrologyFM(m, 4, 0);&#xA;  AddMetrologyCL(m, 0xD0405050, 2, 2);&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</RP45>
		</MODEL>
		<TRR/>
		<TRR_MODEL/>
	</Глубиномер>
	<electro SETUP_METR="--begin&#xA;--//коэффициенты КС&#xA;--// tochno  //mV&#xA; SetIfNotExist(t, 'kGZ1' , 1);&#xA; SetIfNotExist(t, 'kGZ2' , 1);&#xA; SetIfNotExist(t, 'kGZ3' , 1);&#xA; SetIfNotExist(t, 'kGZ4' , 1);&#xA; SetIfNotExist(t, 'kGZ5' , 1);&#xA; SetIfNotExist(t, 'kGZ6' , 1);&#xA;&#xA;  --[[t.kGZ1 = 1;&#xA;  t.kGZ2 = 1;&#xA;  t.kGZ3 = 1;&#xA;  t.kGZ4 = 1;&#xA;  t.kGZ5 = 1;&#xA;  t.kGZ6 = 1;--]]&#xA;--  // grubo //mV&#xA;--//  t.kgz1 := 1;&#xA;--//  t.kgz2 := 1;&#xA;--//  t.kgz3 := 1;&#xA;--//  t.kgz4 := 1;&#xA;--//  t.kgz5 := 1;&#xA;--//  t.kgz6 := 1;&#xA;&#xA; SetIfNotExist(t, 'kI' , 1);&#xA; SetIfNotExist(t, 'kPS1' , 1);&#xA; SetIfNotExist(t, 'kPS2' , 1);&#xA; SetIfNotExist(t, 'kPS3' , 1);&#xA; SetIfNotExist(t, 'kI11_16' , 1);&#xA; SetIfNotExist(t, 'kI21_26' , 1);&#xA; SetIfNotExist(t, 'kU0' , 1);&#xA;&#xA;--[[  t.kI = 1;  --//mA&#xA;&#xA;  t.kPS1 = 1; --//mV&#xA;  t.kPS2 = 1; --//mV&#xA;  t.kPS3 = 1; --//mV&#xA;--//  коэффициенты БК&#xA;  t.kI11_16 = 1;  --//mA&#xA;  t.kI21_26 = 1;  --//mA&#xA;  t.kU0 = 1;      --//mV--]]&#xA;--end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<EL1 EXEC_METR="--{ procedure (v: variant);&#xA;--  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  Exec_EL1(v, t);&#xA;--end;&#xA;" SETUP_METR="--{ procedure (v: variant);&#xA;--  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--begin&#xA;  Setup_EL1(v);&#xA;--end;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</EL1>
		</MODEL>
		<TRR_MODEL>
			<TBK>
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA;--//       TrrFile -- файл тарировки&#xA;-- //       NewTrr -- источник данных&#xA;-- //       'ReportNNK1.ods' -- шаблон в Devices&#xA;-- //       'ReportNNK1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  ExportToCalc('ReportBK.ods', 'ReportBK.xml', TrrFile, NewTrr);&#xA;end&#xA;" EXPORT1="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в печать диаграмм(*.mbk)|*.mbk';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportToMbk( TrrFile, NewTrr);&#xA;end&#xA;"/>
			</TBK>
		</TRR_MODEL>
	</electro>
	<БКС SETUP_METR="&#xA;do&#xA; if not HasXmlPath(t, 'focus1') then &#xA;  local AddTrr = function(root)&#xA;					root.K = 1&#xA;					root.D = 0&#xA;				 end&#xA;  for i = 1, 3 do&#xA;    local f = AddXmlPath(t, 'focus'..i);&#xA;    AddTrr(AddXmlPath(f, 'Ifocus'))&#xA;	for j = 1, 8 do&#xA;      AddTrr(AddXmlPath(f, 'I'..j))		&#xA;    end&#xA;    AddTrr(AddXmlPath(f, 'Izond'))&#xA;    AddTrr(AddXmlPath(f, 'dU'))&#xA;  end &#xA;    AddTrr(AddXmlPath(t, 'Ubk'))&#xA; -- DebugLog('GGKP установки', 'params:', run_path, run_address);&#xA; end&#xA;end&#xA;&#xA;"><IMPORT/>
		<EXPORT/>
		<MODEL>
			<BKS1 EXEC_METR="--{ procedure ( v, t, run_path, run_address);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;do&#xA;  local AddTrr = function(dat, t, cor) &#xA;					cor = cor or 1	&#xA;                    local Res;&#xA;                    if cor == 0 then   			&#xA;                       Res = 0&#xA;                    else &#xA;					   Res = (t.K*dat.DEV.VALUE + t.D)/cor&#xA;					end&#xA;					dat.CLC.VALUE = Res&#xA;					return Res&#xA;				 end&#xA;&#xA;  local Ubk = AddTrr(v.Ubk, t.Ubk)&#xA;&#xA;  for i = 1, 3 do&#xA;    local fv = v['focus'..i];&#xA;    local ft = t['focus'..i];&#xA;    AddTrr(fv.Ifocus, ft.Ifocus)--, Ubk)&#xA;	for j = 1, 8 do&#xA;      AddTrr(fv['I'..j], ft['I'..j])--, Ubk)		&#xA;    end&#xA;    AddTrr(fv.Izond, ft.Izond)--, Ubk)&#xA;    AddTrr(fv.dU, ft.dU)&#xA;  end &#xA;&#xA; local facc, acc = FindXmlRoot(v, run_path, 'accel')&#xA;  if facc then&#xA;    local otk = acc['отклонитель'].CLC.VALUE&#xA;&#xA;	--otk = 360;&#xA;&#xA;    for i = 1,3 do&#xA;      local f = v['focus'..i];&#xA;      f.Ixy.CLC.VALUE ,f.FazaXY.CLC.VALUE, f.Iz.CLC.VALUE = FindBKS(f, otk)&#xA;    end&#xA;  end--]]&#xA; --DebugLog('bkS выполнение', 'params:', run_path, run_address, Ubk);&#xA;end&#xA;" SETUP_METR=" &#xA;do&#xA;  local AddMetr = function (item, name, units, digits, toler, rgL, rgH, color, width, dash)&#xA;					local m&#xA;					m = AddMetrology(item, name, units);&#xA;					AddMetrologyFM(m, digits, toler);&#xA;					AddMetrologyRG(m, rgL, rgH);&#xA;					AddMetrologyCL(m, color, width, dash);&#xA;                  end &#xA;&#xA;  AddMetr(v.Ubk, 'Ubk', 'mV', 8,1, 0,3000, 0xFFFF0000, 2, 0)&#xA;  for i = 1,3 do&#xA;    local f = v['focus'..i]&#xA;    AddMetr(f.dU,    'dU', 'mV', 8,1, 0,3000, 0xFFF00000+i*50, 3, 0)    &#xA;    AddMetr(f.Ifocus, 'If', 'mA', 8,3, 0,1000, 0xFFF88000+i*50, 3, 0)    &#xA;    AddMetr(f.Izond,  'Iz', 'mA', 8,1, 0,1000, 0xFFFF8000+i*50, 3, 0)    &#xA;    for j = 1,8 do&#xA;       AddMetr(f['I'..j],  'I'..j, 'mA', 8,3, 0,1000, 0xF080FF00+i*20, 1, 0)    &#xA;    end&#xA;    AddMetr(AddXmlPath(f, 'Iz'),    'Iz', 'mA', 8,1, 0,1000, 0xFFFF00F0, 2, 0)    &#xA;    AddMetr(AddXmlPath(f, 'Ixy'),  'Ixy', 'mA', 8,1, 0,1000, 0xFFFF00F0, 2, 0)    &#xA;  --  AddMetr(AddXmlPath(f, 'Rz'),   'Rz', 'Om', 8,1, 0,1000, 0xFFFFF000, 4, 0)    &#xA;  --  AddMetr(AddXmlPath(f, 'Rxy'), 'Rxy', 'Om', 8,1, 0,1000, 0xFFF0F000, 4, 0)    &#xA;    AddMetr(AddXmlPath(f, 'FazaXY'),  'FazaXY', 'Grad', 8,1, -180, 180, 0xFFFF0000, 3, 0)&#xA;  end&#xA;end&#xA;"><IMPORT/>
				<EXPORT/>
			</BKS1></MODEL>
		<TRR_MODEL>
			<TBKS1 EXEC_METR="function execute_step(stp, alg, trr)&#xA;&#xA;  local st = AddXmlPath(alg, 'STEP'..stp)&#xA;  local path = 'focus'..math.floor(st.FOCUS)..'.'..st.CNL&#xA;  local current = AddXmlPath(st, path..'.DEV').VALUE&#xA;&#xA; -- DebugLog('BRC exec', 'PATH:', path,' STEP', stp);&#xA;&#xA;  local ubk = st.Ubk.DEV.VALUE &#xA;  local k = alg.Kubk/alg.R&#xA;  &#xA; -- DebugLog('BRC exec', k);&#xA;&#xA;  local Kcurrent = AddXmlPath(trr, path) &#xA;	&#xA;  if (current &gt; 0) then&#xA;    k = ubk*k/current &#xA;  else&#xA;    k = 1&#xA;  end;&#xA;  Kcurrent.K = k -- в метрологии&#xA;  st.K = k -- в таблице ]]--&#xA;end&#xA;" SETUP_METR="-- var&#xA;  local CNL1 ={'Ifocus', 'I1', 'I2', 'I3', 'I4', 'I5', 'I6', 'I7', 'I8'};&#xA;&#xA;  local InitStep = function (stp, focus, cnl)&#xA;	local AddDevClc = function (r)&#xA;		AddXmlPath(r,'CLC');&#xA;		AddXmlPath(r,'DEV');&#xA;		r.CLC.VALUE = 0;&#xA;		r.DEV.VALUE = 0;&#xA;	end&#xA;    local s = AddXmlPath(t, 'STEP'..stp);&#xA;    s.EXECUTED = false;&#xA;    s.STEP = stp;&#xA;    s.FOCUS = focus;&#xA;    s.CNL = CNL1[cnl];&#xA;	s.K = 1;&#xA;    s.INFO = 'Шаг: '..stp..'  Фокус: '..focus..'  Канал: '..s.CNL; &#xA;    local bks = s; --AddXmlPath(s,'БКС');&#xA;    AddDevClc(AddXmlPath(bks,'Ubk'));&#xA;    AddDevClc(AddXmlPath(bks,'focus'..focus..'.'..s.CNL));&#xA;    return s;&#xA;  end&#xA;--begin&#xA;  local i, j;&#xA;  for j = 1, 3 do&#xA;  for i = 1, 9 do&#xA;    local s = InitStep(i+(j-1)*9, j, i); &#xA;   end&#xA;  end&#xA;--end&#xA;"><IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA;--//       TrrFile -- файл тарировки&#xA;-- //       NewTrr -- источник данных&#xA;-- //       'ReportNNK1.ods' -- шаблон в Devices&#xA;-- //       'ReportNNK1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  ExportToCalc('ReportBK.ods', 'ReportBK.xml', TrrFile, NewTrr);&#xA;end&#xA;" EXPORT1="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в печать диаграмм(*.bks)|*.bks';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportToBKS( TrrFile, NewTrr);&#xA;end&#xA;"/>
			</TBKS1></TRR_MODEL>
	</БКС><ВИК SETUP_METR="--begin&#xA;&#xA;--end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<VIK108 EXEC_METR="--{ procedure (v: variant);&#xA;--  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;local ToF,ToDb;&#xA;  &#xA;ToF = function(arg);&#xA;  if arg &gt; 1 then &#xA;    arg = 1 &#xA;  elseif arg &lt; -1 then &#xA;    arg = -1 &#xA;  end;   &#xA;  return math.deg(math.acos(arg));&#xA;end;&#xA;&#xA;ToDb = function(n);&#xA;  local ampB = v['амплитуда']['B'..n].DEV.VALUE;&#xA;  if ampB == 0 then &#xA;    return 0&#xA;  else&#xA;    return 10*math.log(v['амплитуда']['A'..n].DEV.VALUE/ampB)&#xA;  end;&#xA;end;&#xA;&#xA;--begin&#xA;  local f = v['фаза']&#xA;  f.f1.CLC.VALUE = ToF(f.f1.DEV.VALUE);&#xA;  f.f2.CLC.VALUE = ToF(f.f2.DEV.VALUE);&#xA;  f.f3.CLC.VALUE = ToF(f.f3.DEV.VALUE);&#xA;  f.f4.CLC.VALUE = ToF(f.f4.DEV.VALUE);&#xA;  v['Амп1'].CLC.VALUE = ToDb(1);&#xA;  v['Амп2'].CLC.VALUE = ToDb(2);&#xA;  v['Амп3'].CLC.VALUE = ToDb(3);&#xA;  v['Амп4'].CLC.VALUE = ToDb(4);&#xA;--end;&#xA;&#xA;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;--// Форматирование и вычисляемые параметры&#xA;  local m;&#xA;&#xA;  m = AddMetrology(v['фаза'].f1, 'F1', 'GRAD');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xFF4F0000, 3, 1);&#xA;&#xA;  m = AddMetrology(v['фаза'].f2, 'F2', 'GRAD');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xFF4F0000, 3, 1);&#xA;&#xA;  m = AddMetrology(v['фаза'].f3, 'F3', 'GRAD');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xFFFF0000, 3, 1);&#xA;&#xA;  m = AddMetrology(v['фаза'].f4, 'F4', 'GRAD');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, 0xFF00FF00, 3, 1);&#xA;&#xA;  m = AddMetrology(v['фаза'].f1.DEV, 'F1d', 'sin');&#xA;  AddMetrologyFM(m, 9, 6);&#xA;  m = AddMetrology(v['фаза'].f2.DEV, 'F2d', 'sin');&#xA;  AddMetrologyFM(m, 9, 6);&#xA;  m = AddMetrology(v['фаза'].f3.DEV, 'F3d', 'sin');&#xA;  AddMetrologyFM(m, 9, 6);&#xA;  m = AddMetrology(v['фаза'].f4.DEV, 'F4d', 'sin');&#xA;  AddMetrologyFM(m, 9, 6);&#xA;&#xA;  m = AddMetrology(v['амплитуда'].A1.DEV, 'A1', 'adc');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  m = AddMetrology(v['амплитуда'].A2.DEV, 'A2', 'adc');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  m = AddMetrology(v['амплитуда'].A3.DEV, 'A3', 'adc');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  m = AddMetrology(v['амплитуда'].A4.DEV, 'A4', 'adc');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;&#xA;  m = AddMetrology(v['амплитуда'].B1.DEV, 'B1', 'adc');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  m = AddMetrology(v['амплитуда'].B2.DEV, 'B2', 'adc');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  m = AddMetrology(v['амплитуда'].B3.DEV, 'B3', 'adc');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  m = AddMetrology(v['амплитуда'].B4.DEV, 'B4', 'adc');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  &#xA;  AddXmlPath(v, 'Амп1');&#xA;  m = AddMetrology(v['Амп1'], 'Амп1', 'дБ');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0000080, 2, 2);&#xA;  AddXmlPath(v, 'Амп2');&#xA;  m = AddMetrology(v['Амп2'], 'Амп2', 'дБ');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0800080, 2, 2);&#xA;  AddXmlPath(v, 'Амп3');&#xA;  m = AddMetrology(v['Амп3'], 'Амп3', 'дБ');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xC0F00080, 2, 2);&#xA;  AddXmlPath(v, 'Амп4');&#xA;  m = AddMetrology(v['Амп4'], 'Амп4', 'дБ');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, 0xF0800080, 2, 2);&#xA;&#xA;&#xA;--end;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</VIK108>
		</MODEL>
		<TRR_MODEL/>
	</ВИК>
	<ННК SETUP_METR="--begin&#xA;&#xA;  SetIfNotExist(t, 'kNGK' , 1);&#xA;  SetIfNotExist(t, 'KW1' , 700);&#xA;  SetIfNotExist(t, 'KW2' , 70);&#xA;  SetIfNotExist(t, 'KWG' , 100);&#xA;&#xA;  --t.kNGK = 1;&#xA;  --t.KW1 = 700;&#xA;  --t.KW2 = 70;&#xA;  --t.KWG = 100;&#xA;&#xA;  AddXmlPath(t, 'Rbf.A');&#xA;  AddXmlPath(t, 'Rbf.K1');&#xA;  AddXmlPath(t, 'Rbf.K2');&#xA;  AddXmlPath(t, 'Rbf.G');&#xA;&#xA;  SetIfNotExist(t.Rbf.A, 'XY' , '');&#xA;  SetIfNotExist(t.Rbf.K1, 'XY' , '');&#xA;  SetIfNotExist(t.Rbf.K2, 'XY' , '');&#xA;  SetIfNotExist(t.Rbf.G, 'XY' , '');&#xA;  --t.Rbf.A.XY = '';&#xA;  --t.Rbf.K1.XY = '';&#xA;  --t.Rbf.K2.XY = '';&#xA;  --t.Rbf.G.XY = '';&#xA;--end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<NNK1 EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--  var&#xA;   --p: variant;&#xA;--   dv, k1, k2, kg, dia: double;&#xA;--begin&#xA;  v['нгк'].CLC.VALUE = t.kNGK * v['нгк'].DEV.VALUE;&#xA;&#xA;  dia = 216/200;--// GetProjectData('Диаметр'); // как вариант не создавать в &quot;Установках&quot; а создать директорию? файл? проект&#xA;&#xA;  if t.Rbf.A.XY == ''  then &#xA;    return;&#xA;  end&#xA;  --//if not XmlPathExists(t, 'RUN') then Exit;&#xA;&#xA;  if v['нк1'].DEV.VALUE == 0 then &#xA;     k1 = t.KW1 &#xA;  else &#xA;     k1 = t.KW1 / v['нк1'].DEV.VALUE;&#xA;  end &#xA;&#xA;  if v['нк2'].DEV.VALUE == 0 then &#xA;    k2 = t.KW2 &#xA;  else &#xA;    k2 = t.KW2 / v['нк2'].DEV.VALUE;&#xA;  end&#xA;&#xA;  if k1 == 0 then &#xA;    dv = k2 &#xA;   else &#xA;    dv = k2/k1;&#xA;  end;&#xA;				--run_path ='WRK'&#xA;  local f, p = FindXmlRoot(v, run_path, 'ГК')&#xA;  if f and (v['нгк'].CLC.VALUE &gt; p['гк'].CLC.VALUE) then&#xA;     kg = t.KWG/ (v['нгк'].CLC.VALUE - p['гк'].CLC.VALUE) * t.kNGK;&#xA;  elseif v['нгк'].CLC.VALUE == 0 then&#xA;     kg = t.KWG&#xA;  else&#xA;     kg = t.KWG/v['нгк'].CLC.VALUE * t.kNGK;&#xA;  end&#xA;&#xA;  v['Кп'].CLC.VALUE = RbfInterp(t.Rbf.A, dia, dv);&#xA;  v['Кпг'].CLC.VALUE = RbfInterp(t.Rbf.G, dia, kg);&#xA;  v['Кпм'].CLC.VALUE = RbfInterp(t.Rbf.K1, dia, k1);&#xA;  v['Кпб'].CLC.VALUE = RbfInterp(t.Rbf.K2, dia, k2);&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;  AddXmlPath(v, 'Кп');&#xA;  AddXmlPath(v, 'Кпм');&#xA;  AddXmlPath(v, 'Кпб');&#xA;  AddXmlPath(v, 'Кпг');&#xA;--  // переменная вводится вручную или саздать в проекте?&#xA;  AddXmlPath(v, 'Диаметр');&#xA;&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m = AddMetrology(v['нгк'], 'нгк', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кп'], 'Кп', '%', 1.1);&#xA;  AddMetrologyFM(m, 1, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кпм'], 'Кпм', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кпб'], 'Кпб', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кпг'], 'Кпг', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Диаметр'], 'Диаметр', 'мм', 1.1);&#xA;  AddMetrologyFM(m, 8, 0);&#xA;&#xA;  v['Диаметр'].CLC.VALUE = 216;&#xA;&#xA;--//  AddXmlPath(v, 'Диаметр');&#xA;--//  AddMetrology(v.Диаметр, 'мм.', '%1.0f', 0, 400);&#xA;--//  v.Диаметр.CLC.VALUE := 216;&#xA;--//  DivArray(t.нк1,  t.нк2,  t.нк);&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</NNK1>
			<NNKBB1 EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--  var&#xA;   --p: variant;&#xA;--   dv, k1, k2, kg, dia: double;&#xA;--begin&#xA;  dia = 216/200;--// GetProjectData('Диаметр'); // как вариант не создавать в &quot;Установках&quot; а создать директорию? файл? проект&#xA;&#xA;  if t.Rbf.A.XY == ''  then &#xA;    return;&#xA;  end&#xA;  --//if not XmlPathExists(t, 'RUN') then Exit;&#xA;&#xA;  if v['нк1'].DEV.VALUE == 0 then &#xA;     k1 = t.KW1 &#xA;  else &#xA;     k1 = t.KW1 / v['нк1'].DEV.VALUE;&#xA;  end &#xA;&#xA;  if v['нк2'].DEV.VALUE == 0 then &#xA;    k2 = t.KW2 &#xA;  else &#xA;    k2 = t.KW2 / v['нк2'].DEV.VALUE;&#xA;  end&#xA;&#xA;  if k1 == 0 then &#xA;    dv = k2 &#xA;   else &#xA;    dv = k2/k1;&#xA;  end;&#xA;				--run_path ='WRK'&#xA;--[[  local f, p = FindXmlRoot(v, run_path, 'ГК')&#xA;  if f and (v['нгк'].CLC.VALUE &gt; p['гк'].CLC.VALUE) then&#xA;     kg = t.KWG/ (v['нгк'].CLC.VALUE - p['гк'].CLC.VALUE) * t.kNGK;&#xA;  elseif v['нгк'].CLC.VALUE == 0 then&#xA;     kg = t.KWG&#xA;  else&#xA;     kg = t.KWG/v['нгк'].CLC.VALUE * t.kNGK;&#xA;  end--]]&#xA;&#xA;  v['Кп'].CLC.VALUE = RbfInterp(t.Rbf.A, dia, dv);&#xA;  v['Кпг'].CLC.VALUE = RbfInterp(t.Rbf.G, dia, kg);&#xA;  v['Кпм'].CLC.VALUE = RbfInterp(t.Rbf.K1, dia, k1);&#xA;  v['Кпб'].CLC.VALUE = RbfInterp(t.Rbf.K2, dia, k2);&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA;  AddXmlPath(v, 'Кп');&#xA;  AddXmlPath(v, 'Кпм');&#xA;  AddXmlPath(v, 'Кпб');&#xA;  AddXmlPath(v, 'Кпг');&#xA;--  // переменная вводится вручную или саздать в проекте?&#xA;  AddXmlPath(v, 'Диаметр');&#xA;&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;--[[  m = AddMetrology(v['нгк'], 'нгк', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFFFF0000);--]]&#xA;&#xA;  m = AddMetrology(v['Кп'], 'Кп', '%', 1.1);&#xA;  AddMetrologyFM(m, 1, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кпм'], 'Кпм', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кпб'], 'Кпб', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кпг'], 'Кпг', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Диаметр'], 'Диаметр', 'мм', 1.1);&#xA;  AddMetrologyFM(m, 8, 0);&#xA;&#xA;  v['Диаметр'].CLC.VALUE = 216;&#xA;&#xA;--//  AddXmlPath(v, 'Диаметр');&#xA;--//  AddMetrology(v.Диаметр, 'мм.', '%1.0f', 0, 400);&#xA;--//  v.Диаметр.CLC.VALUE := 216;&#xA;--//  DivArray(t.нк1,  t.нк2,  t.нк);&#xA;--end;&#xA;&#xA;"><IMPORT/>
				<EXPORT/>
			</NNKBB1></MODEL>
		<TRR_MODEL>
			<TNGK EXEC_METR="function execute_step(stp, alg, trr)&#xA;-- var&#xA;--  st: variant;&#xA;--  a, Dz: Double;&#xA;--begin&#xA;  if alg.STEP7['нгк'].DEV.VALUE ~= alg.STEP3['нгк'].DEV.VALUE then&#xA;       trr.kNGK = 40/(alg.STEP7['нгк'].DEV.VALUE - alg.STEP3['нгк'].DEV.VALUE);&#xA;  end&#xA;&#xA;  a = trr.kNGK;&#xA;&#xA;  Dz = alg.STEP1['нгк'].DEV.VALUE * a;&#xA;&#xA;  trr.Delta = alg.STEP1['нгк'].DEV.VALUE;&#xA;&#xA;  if stp == 1 then &#xA;     alg.STEP1['нгк'].CLC.VALUE = Dz&#xA;  else   &#xA;    st = AddXmlPath(alg, 'STEP'..stp);&#xA;    st['нгк'].CLC.VALUE = st['нгк'].DEV.VALUE * a - Dz;&#xA;    st.DELTA = (st['нгк'].CLC.VALUE - st.RT)*100/st.RT;&#xA;   end&#xA;end&#xA;" SETUP_METR="-- var&#xA;--  i: Integer;&#xA;--  s, d, e: Variant;&#xA;--begin&#xA;  local i, s, d, e;&#xA;  local GC ={'P0_HOME', 'P5_HOME', 'P10', 'P20', 'P30', 'P40', 'P50', 'P100', 'P150', 'P200'};&#xA;  local RT1 ={0, 5, 10, 20, 30, 40, 50, 100, 150, 200};&#xA;  local INF ={'1) фон 0.','2) - 5','3) 3.095 10','4) 2.188 20','5) 1.787 30','6) 1.547 40','7) 1.384 50','8) 0.979 100','9) 0.799 150','10) 0.692 200'};&#xA;&#xA;  for i = 1, 10 do&#xA;--   begin&#xA;    s = AddXmlPath(t, 'STEP'..i);&#xA;    s.EXECUTED = false;&#xA;    s.STEP = i;&#xA;    s.DELTA = 0;&#xA;    s.RT = RT1[i];&#xA;    s.INFO = INF[i]; &#xA;    d = AddXmlPath(s,'нгк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE = 0;&#xA;    d.DEV.VALUE = 0;&#xA;    e = AddXmlPath(s,'TASK');&#xA;    e.Gk_Stol = GC[i];&#xA;   end&#xA;&#xA; t.STEP1.ATT_COUNT = 40;&#xA; t.STEP3.ATT_COUNT = 40;&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportGKToCalc(TrrFile, NewTrr, 'NGK');&#xA;end&#xA;" EXPORT1="function GetFilterName()&#xA;&#xA;  return ' Unif Экспортирование в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA; --//       TrrFile -- файл тарировки&#xA; --//       NewTrr -- источник данных&#xA; --//       'ReportNNK1.ods' -- шаблон в Devices&#xA; --//       'ReportNNK1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  ExportToCalc('ReportGK.ods', 'ReportNGK.xml', TrrFile, NewTrr);&#xA;end&#xA;"/>
			</TNGK>
			<TNGK_LS EXEC_METR="function execute_step(stp, alg, trr)&#xA;  ExecStepGK1(stp, alg, trr, false);&#xA;end;&#xA;" SETUP_METR="-- var&#xA;--  i: Integer;&#xA;--  s, d, e: Variant;&#xA;--begin&#xA;  for i = 1, 10 do&#xA;--   begin&#xA;    s = AddXmlPath(t, 'STEP'..i);&#xA;    s.EXECUTED = False;&#xA;    s.STEP = i;&#xA;    s.DELTA = 0;&#xA;    d = AddXmlPath(s,'нгк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE = 0;&#xA;    d.DEV.VALUE = 0;&#xA;    e = AddXmlPath(s,'TASK');&#xA;   end&#xA;&#xA; t.STEP1.ATT_COUNT = 40;&#xA;--// t.STEP2.ATT_COUNT := 30;&#xA; t.STEP3.ATT_COUNT = 40;&#xA;--// t.STEP4.ATT_COUNT := 30;&#xA;--// t.STEP5.ATT_COUNT := 30;&#xA;--// t.STEP6.ATT_COUNT := 30;&#xA;--// t.STEP7.ATT_COUNT := 40;&#xA;--// t.STEP8.ATT_COUNT := 30;&#xA;--// t.STEP9.ATT_COUNT := 30;&#xA;--// t.STEP10.ATT_COUNT := 30;&#xA;&#xA;&#xA; t.STEP1.TASK.Gk_Stol = 'P0_HOME';&#xA; t.STEP2.TASK.Gk_Stol = 'P5_HOME';&#xA; t.STEP3.TASK.Gk_Stol = 'P10';&#xA; t.STEP4.TASK.Gk_Stol = 'P20';&#xA; t.STEP5.TASK.Gk_Stol = 'P30';&#xA; t.STEP6.TASK.Gk_Stol = 'P40';&#xA; t.STEP7.TASK.Gk_Stol = 'P50';&#xA; t.STEP8.TASK.Gk_Stol = 'P100';&#xA; t.STEP9.TASK.Gk_Stol = 'P150';&#xA; t.STEP10.TASK.Gk_Stol = 'P200';&#xA;&#xA; t.STEP1.RT = 0;&#xA; t.STEP2.RT = 5;&#xA; t.STEP3.RT = 10;&#xA; t.STEP4.RT = 20;&#xA; t.STEP5.RT = 30;&#xA; t.STEP6.RT = 40;&#xA; t.STEP7.RT = 50;&#xA; t.STEP8.RT = 100;&#xA; t.STEP9.RT = 150;&#xA; t.STEP10.RT = 200;&#xA;&#xA; t.STEP1.INFO = '1) фон 0.';&#xA; t.STEP2.INFO = '2) - 5';&#xA; t.STEP3.INFO = '3) 3.095 10';&#xA; t.STEP4.INFO = '4) 2.188 20';&#xA; t.STEP5.INFO = '5) 1.787 30';&#xA; t.STEP6.INFO = '6) 1.547 40';&#xA; t.STEP7.INFO = '7) 1.384 50';&#xA; t.STEP8.INFO = '8) 0.979 100';&#xA; t.STEP9.INFO = '9) 0.799 150';&#xA; t.STEP10.INFO = '10) 0.692 200';&#xA;--end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName()&#xA;&#xA;  return 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;  ExportGKToCalc(TrrFile, NewTrr, 'NGK');&#xA;end&#xA;"/>
			</TNGK_LS>
			<TNGK_old EXEC_METR="procedure execute_step(stp: integer; alg, trr: variant);&#xA; var&#xA;  st: variant;&#xA;  a, Dz: Double;&#xA;begin&#xA;  if alg.STEP7.нгк.ROW &lt;&gt; alg.STEP3.нгк.ROW then&#xA;       trr.kNGK := 40/(alg.STEP7.нгк.ROW - alg.STEP3.нгк.ROW);&#xA;&#xA;  a := trr.kNGK;&#xA;&#xA;  Dz := alg.STEP1.нгк.ROW * a;&#xA;&#xA;  if stp = 1 then alg.STEP1.нгк.TRR := Dz&#xA;  else&#xA;   begin&#xA;    st := AddXmlPath(alg, 'STEP' + IntToStr(stp));&#xA;    st.нгк.TRR := st.нгк.ROW * a - Dz;&#xA;    st.DELTA := (st.нгк.TRR - st.RT)*100/st.RT;&#xA;   end;&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d: Variant;&#xA;begin&#xA;  for i := 1 to 10 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i) );&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    s.DELTA := 0;&#xA;    d := AddXmlPath(s,'нгк');&#xA;    d.TRR := 0;&#xA;    d.ROW := 0;&#xA;   end;&#xA;&#xA; t.STEP1.DISTANCE := 'фон';&#xA; t.STEP2.DISTANCE := '-';&#xA; t.STEP3.DISTANCE := '3.095';&#xA; t.STEP4.DISTANCE := '2.188';&#xA; t.STEP5.DISTANCE := '1.787';&#xA; t.STEP6.DISTANCE := '1.547';&#xA; t.STEP7.DISTANCE := '1.384';&#xA; t.STEP8.DISTANCE := '0.979';&#xA; t.STEP9.DISTANCE := '0.799';&#xA; t.STEP10.DISTANCE := '0.692';&#xA;&#xA; t.STEP1.RT := 0;&#xA; t.STEP2.RT := 5;&#xA; t.STEP3.RT := 10;&#xA; t.STEP4.RT := 20;&#xA; t.STEP5.RT := 30;&#xA; t.STEP6.RT := 40;&#xA; t.STEP7.RT := 50;&#xA; t.STEP8.RT := 100;&#xA; t.STEP9.RT := 150;&#xA; t.STEP10.RT := 200;&#xA;&#xA; t.STEP1.INFO := '1) фон 0.';&#xA; t.STEP2.INFO := '2) - 5';&#xA; t.STEP3.INFO := '3) 3.095 10';&#xA; t.STEP4.INFO := '4) 2.188 20';&#xA; t.STEP5.INFO := '5) 1.787 30';&#xA; t.STEP6.INFO := '6) 1.547 40';&#xA; t.STEP7.INFO := '7) 1.384 50';&#xA; t.STEP8.INFO := '8) 0.979 100';&#xA; t.STEP9.INFO := '9) 0.799 150';&#xA; t.STEP10.INFO := '10) 0.692 200';&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</TNGK_old>
			<TNNK EXEC_METR="&#xA;--var&#xA;--  k, k1, k2, kg: Double;&#xA;&#xA;function execute_step(stp, alg, trr)&#xA;&#xA;-- var&#xA;--  st: variant;&#xA;--  i: Integer;&#xA;--  dia, xy, xy1, xy2, xyg: string;&#xA;&#xA;FindPoint = function()&#xA;    if st['нк2'].DEV.VALUE == 0 then st.nkw = k * st['нк1'].DEV.VALUE else st.nkw = k * st['нк1'].DEV.VALUE/st['нк2'].DEV.VALUE end;&#xA;    if st['нк1'].DEV.VALUE == 0 then st.nkw1 = k1 else st.nkw1 = k1/st['нк1'].DEV.VALUE end;&#xA;    if st['нк2'].DEV.VALUE == 0 then st.nkw2 = k2 else st.nkw2 = k2/st['нк2'].DEV.VALUE end;&#xA;    if st['нгк'].DEV.VALUE == 0 then st.nkwg = kg else st.nkwg = kg/st['нгк'].DEV.VALUE end;&#xA;  end;&#xA;&#xA;   st = AddXmlPath(alg, 'STEP'..stp);&#xA;&#xA;   if stp == 1 then  --case stp of&#xA;   --1: begin&#xA;        k1 = st['нк1'].DEV.VALUE;&#xA;        k2 = st['нк2'].DEV.VALUE;&#xA;        kg = st['нгк'].DEV.VALUE;&#xA;        if k1 == 0 then k = k2 else k = k2/k1 end;&#xA;        FindPoint();&#xA;   elseif stp == 14 then&#xA;       -- 14: begin&#xA;        k1 = (alg.STEP1['нк1'].DEV.VALUE + alg.STEP11['нк1'].DEV.VALUE)/2;&#xA;        k2 = (alg.STEP1['нк2'].DEV.VALUE + alg.STEP11['нк2'].DEV.VALUE)/2;&#xA;        kg = (alg.STEP1['нгк'].DEV.VALUE + alg.STEP11['нгк'].DEV.VALUE)/2;&#xA;        if k1 == 0 then k = k2 else k = k2/k1 end;&#xA;        --// коэфф полученн при тарировке&#xA;        trr.KW1 = k1;&#xA;        trr.KW2 = k2;&#xA;        --//trr.KW := k; лишнее&#xA;        trr.KWG = kg;&#xA;        local xy = '[';  local xy1 = '['; local xy2 = '['; local xyg = '[';&#xA;        for i = 1,14 do&#xA;         --begin&#xA;          st = AddXmlPath(alg, 'STEP'..i);&#xA;          FindPoint();&#xA;          if (i ~= 1) and (i ~= 11) then&#xA;   dia = st.D/200;&#xA;   xy  = xy ..'['..dia..','..st.nkw..','..st.KP..']';&#xA;   xy1 = xy1..'['..dia..','..st.nkw1..','..st.KP..']';&#xA;   xy2 = xy2..'['..dia..','..st.nkw2..','..st.KP..']';&#xA;   xyg = xyg..'['..dia..','..st.nkwg..','..st.KP..']';&#xA;   if i == 14 then &#xA;                xy = xy..']'; &#xA;    xy1 = xy1..']'            &#xA;    xy2 = xy2..']'&#xA;    xyg = xyg..']' &#xA;   else &#xA;    xy  = xy..','; &#xA;    xy1 = xy1..', ' &#xA;    xy2 = xy2..',' &#xA;    xyg = xyg..',' &#xA;            end;&#xA;          end;&#xA;    st = AddXmlPath(trr, 'Rbf.A'); st.XY = xy;&#xA;          st = AddXmlPath(trr, 'Rbf.K1'); st.XY = xy1;&#xA;          st = AddXmlPath(trr, 'Rbf.K2'); st.XY = xy2;&#xA;          st = AddXmlPath(trr, 'Rbf.G'); st.XY = xyg;&#xA;        end       &#xA;   else &#xA;        FindPoint();&#xA;   end&#xA;end&#xA;&#xA;" SETUP_METR="-- var&#xA;--  i: Integer;&#xA;--  s, d: Variant;&#xA;---begin&#xA;  for i = 1,14 do&#xA;   &#xA;    s = AddXmlPath(t, 'STEP'..i);&#xA;    s.EXECUTED = false;&#xA;    s.STEP = i;&#xA;    d = AddXmlPath(s,'нк1');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE = 0;&#xA;    d.DEV.VALUE = 0;&#xA;    d = AddXmlPath(s,'нк2');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE = 0;&#xA;    d.DEV.VALUE = 0;&#xA;    d = AddXmlPath(s,'нгк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE = 0;&#xA;    d.DEV.VALUE = 0;&#xA;   end;&#xA;&#xA; t.STEP1.KP = 'Вода';&#xA; t.STEP1.ATT_COUNT = t.AttCount_Voda;&#xA; t.STEP2.KP = '0.6';&#xA; t.STEP3.KP = '18.2';&#xA; t.STEP4.KP = '36.5';&#xA;&#xA; t.STEP5.KP = '0.7';&#xA; t.STEP6.KP = '18.2';&#xA; t.STEP7.KP = '36.5';&#xA;&#xA; t.STEP8.KP = '0.7';&#xA; t.STEP9.KP = '18.2';&#xA; t.STEP10.KP = '36.5';&#xA;&#xA; t.STEP11.KP = 'Вода';&#xA; t.STEP11.ATT_COUNT = t.AttCount_Voda;&#xA; t.STEP12.KP = '0.7';&#xA; t.STEP13.KP = '18.2';&#xA; t.STEP14.KP = '36.5';&#xA;&#xA; t.STEP1.D = 124;&#xA; t.STEP2.D = 124;&#xA; t.STEP3.D = 124;&#xA; t.STEP4.D = 124;&#xA;&#xA; t.STEP5.D = 156;&#xA; t.STEP6.D = 156;&#xA; t.STEP7.D = 156;&#xA;&#xA; t.STEP8.D = 216;&#xA; t.STEP9.D = 216;&#xA; t.STEP10.D = 216;&#xA;&#xA; t.STEP11.D = 295;&#xA; t.STEP12.D = 295;&#xA; t.STEP13.D = 295;&#xA; t.STEP14.D = 295;&#xA;&#xA; t.STEP1.INFO = '1) 124  вода';&#xA; t.STEP2.INFO = '2) 124  0.6';&#xA; t.STEP3.INFO = '3) 124  18.2';&#xA; t.STEP4.INFO = '4) 124  36.5';&#xA;&#xA; t.STEP5.INFO = '5) 156  0.7';&#xA; t.STEP6.INFO = '6) 156  18.2';&#xA; t.STEP7.INFO = '7) 156  36.5';&#xA;&#xA; t.STEP8.INFO = '8) 216  0.7';&#xA; t.STEP9.INFO = '9) 216  18.2';&#xA; t.STEP10.INFO = '10) 216  36.5';&#xA;&#xA; t.STEP11.INFO = '10) 295  вода';&#xA; t.STEP12.INFO = '11) 295  0.7';&#xA; t.STEP13.INFO = '12) 295  18.2';&#xA; t.STEP14.INFO = '13) 295  36.5';&#xA; --end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="&#xA;function GetFilterName()&#xA;&#xA;  return 'Экспортирование в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA;-- //       TrrFile -- файл тарировки&#xA;-- //       NewTrr -- источник данных&#xA;-- //       'ReportNNK1.ods' -- шаблон в Devices&#xA;-- //       'ReportNNK1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  ExportToCalc('ReportNNK.ods', 'ReportNNK.xml', TrrFile, NewTrr);&#xA;end&#xA;"/>
			</TNNK>
			<TNNK_old EXEC_METR="&#xA;var&#xA;  k, k1, k2, kg: Double;&#xA;&#xA;procedure execute_step(stp: integer; alg, trr: variant);&#xA;&#xA; var&#xA;  st: variant;&#xA;  i: Integer;&#xA;  dia, xy, xy1, xy2, xyg: string;&#xA;&#xA;  procedure FindPoint;&#xA;  begin&#xA;    if st.нк2.DEV.VALUE = 0 then st.nkw := k * st.нк1.DEV.VALUE else st.nkw := k * st.нк1.DEV.VALUE/st.нк2.DEV.VALUE;&#xA;    if st.нк1.DEV.VALUE = 0 then st.nkw1 := k1 else st.nkw1 := k1/st.нк1.DEV.VALUE;&#xA;    if st.нк2.DEV.VALUE = 0 then st.nkw2 := k2 else st.nkw2 := k2/st.нк2.DEV.VALUE;&#xA;    if st.нгк.DEV.VALUE = 0 then st.nkwg := kg else st.nkwg := kg/st.нгк.DEV.VALUE;&#xA;  end;&#xA;&#xA;begin&#xA;  st := AddXmlPath(alg, 'STEP' + IntToStr(stp));&#xA;&#xA;  case stp of&#xA;   1,&#xA;   6,&#xA;   10: begin&#xA;        k1 := st.нк1.DEV.VALUE;&#xA;        k2 := st.нк2.DEV.VALUE;&#xA;        kg := st.нгк.DEV.VALUE;&#xA;        if k1 = 0 then k := k2 else k := k2/k1;&#xA;        FindPoint;&#xA;       end;&#xA;&#xA;   13: begin&#xA;        // обязательно *1 иначе считает что вариант - строка&#xA;        k1 := (alg.STEP1.нк1.DEV.VALUE*1 + alg.STEP6.нк1.DEV.VALUE*1 + alg.STEP10.нк1.DEV.VALUE*1)/3;&#xA;        k2 := (alg.STEP1.нк2.DEV.VALUE*1 + alg.STEP6.нк2.DEV.VALUE*1 + alg.STEP10.нк2.DEV.VALUE*1)/3;&#xA;        kg := (alg.STEP1.нгк.DEV.VALUE*1 + alg.STEP6.нгк.DEV.VALUE*1 + alg.STEP10.нгк.DEV.VALUE*1)/3;&#xA;        if k1 = 0 then k := k2 else k := k2/k1;&#xA;        // коэфф полученн при тарировке&#xA;        trr.KW1 := k1;&#xA;        trr.KW2 := k2;&#xA;        //trr.KW := k; лишнее&#xA;        trr.KWG := kg;&#xA;        xy := '[';  xy1 := '['; xy2 := '['; xyg := '[';&#xA;        for i := 1 to 13 do&#xA;         begin&#xA;          st := AddXmlPath(alg, 'STEP' + IntToStr(i));&#xA;          FindPoint;&#xA;          if i in [1,6,10] then Continue;&#xA;          dia := FloatToStr(st.D/200);&#xA;          xy  := xy  + '[' + dia + ',' +st.nkw  + ',' + st.KP + ']';&#xA;          xy1 := xy1 + '[' + dia + ',' +st.nkw1 + ',' + st.KP + ']';&#xA;          xy2 := xy2 + '[' + dia + ',' +st.nkw2 + ',' + st.KP + ']';&#xA;          xyg := xyg + '[' + dia + ',' +st.nkwg + ',' + st.KP + ']';&#xA;          if i = 13 then xy  := xy  + ']' else xy  := xy  + ',';&#xA;          if i = 13 then xy1 := xy1 + ']' else xy1 := xy1 + ',';&#xA;          if i = 13 then xy2 := xy2 + ']' else xy2 := xy2 + ',';&#xA;          if i = 13 then xyg := xyg + ']' else xyg := xyg + ',';&#xA;         end;&#xA;        st := AddXmlPath(trr, 'Rbf.A'); st.XY := xy;&#xA;        st := AddXmlPath(trr, 'Rbf.K1'); st.XY := xy1;&#xA;        st := AddXmlPath(trr, 'Rbf.K2'); st.XY := xy2;&#xA;        st := AddXmlPath(trr, 'Rbf.G'); st.XY := xyg;&#xA;       end;&#xA;&#xA;   else FindPoint;&#xA;  end;&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d: Variant;&#xA;begin&#xA;  for i := 1 to 13 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i) );&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    d := AddXmlPath(s,'нк1');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;    d := AddXmlPath(s,'нк2');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;    d := AddXmlPath(s,'нгк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;   end;&#xA;&#xA; t.STEP1.KP := 'Вода';&#xA; t.STEP2.KP := '0.6';&#xA; t.STEP3.KP := '8.1';&#xA; t.STEP4.KP := '15';&#xA; t.STEP5.KP := '30.9';&#xA; t.STEP6.KP := 'Вода';&#xA; t.STEP7.KP := '0.7';&#xA; t.STEP8.KP := '15.7';&#xA; t.STEP9.KP := '35.5';&#xA; t.STEP10.KP := 'Вода';&#xA; t.STEP11.KP := '0.6';&#xA; t.STEP12.KP := '15.6';&#xA; t.STEP13.KP := '36';&#xA;&#xA; t.STEP1.D := 196;&#xA; t.STEP2.D := 196;&#xA; t.STEP3.D := 196;&#xA; t.STEP4.D := 196;&#xA; t.STEP5.D := 196;&#xA;&#xA; t.STEP6.D := 156;&#xA; t.STEP7.D := 156;&#xA; t.STEP8.D := 156;&#xA; t.STEP9.D := 156;&#xA;&#xA; t.STEP10.D := 124;&#xA; t.STEP11.D := 124;&#xA; t.STEP12.D := 124;&#xA; t.STEP13.D := 124;&#xA;&#xA; t.STEP1.INFO := '1) 196  вода';&#xA; t.STEP2.INFO := '2) 196  0.6';&#xA; t.STEP3.INFO := '3) 196  8.1';&#xA; t.STEP4.INFO := '4) 196  15';&#xA; t.STEP5.INFO := '5) 196  30.9';&#xA; t.STEP6.INFO := '6) 156  вода';&#xA; t.STEP7.INFO := '7) 156  0.7';&#xA; t.STEP8.INFO := '8) 156  15.7';&#xA; t.STEP9.INFO := '9) 156  35.5';&#xA; t.STEP10.INFO := '10) 124  вода';&#xA; t.STEP11.INFO := '11) 124  0.6';&#xA; t.STEP12.INFO := '12) 124  15.6';&#xA; t.STEP13.INFO := '13) 124  36';&#xA;end;&#xA;&#xA;">
				<IMPORT IMPORT0="&#xA;function GetFilterName: string;&#xA;begin&#xA;  Result := 'Импортирование-ННК 10 моделей(*.nnk)|*.nnk';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ImportNNK10(TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
				<EXPORT EXPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование-ННК 10 моделей(*.nnk)|*.nnk';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA; // ImportNNK10(TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
			</TNNK_old>
		</TRR_MODEL>
	</ННК>
	<NNK2X SETUP_METR="--begin&#xA;SetIfNotExist(t, 'AttCount_Voda' , 50);&#xA;  --[[SetIfNotExist(t, 'kNGK' , 1);&#xA;  SetIfNotExist(t, 'KW1' , 700);&#xA;  SetIfNotExist(t, 'KW2' , 70);&#xA;  SetIfNotExist(t, 'KWG' , 100);&#xA;&#xA;  --t.kNGK = 1;&#xA;  --t.KW1 = 700;&#xA;  --t.KW2 = 70;&#xA;  --t.KWG = 100;&#xA;&#xA;  AddXmlPath(t, 'Rbf.A');&#xA;  AddXmlPath(t, 'Rbf.K1');&#xA;  AddXmlPath(t, 'Rbf.K2');&#xA;  AddXmlPath(t, 'Rbf.G');&#xA;&#xA;  SetIfNotExist(t.Rbf.A, 'XY' , '');&#xA;  SetIfNotExist(t.Rbf.K1, 'XY' , '');&#xA;  SetIfNotExist(t.Rbf.K2, 'XY' , '');&#xA;  SetIfNotExist(t.Rbf.G, 'XY' , '');--]]&#xA;  --t.Rbf.A.XY = '';&#xA;  --t.Rbf.K1.XY = '';&#xA;  --t.Rbf.K2.XY = '';&#xA;  --t.Rbf.G.XY = '';&#xA;--end;&#xA;&#xA;"><IMPORT/>
		<EXPORT/>
		<MODEL>
			<NNK2X1 EXEC_METR="--{ procedure ( v, t: variant);&#xA;--  t - корневой элемент метрологии&#xA;--  где v - корневой элемент редактируемого модуля&#xA;--  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;--  var&#xA;   --p: variant;&#xA;--   dv, k1, k2, kg, dia: double;&#xA;--begin&#xA; --[[ v['нгк'].CLC.VALUE = t.kNGK * v['нгк'].DEV.VALUE;&#xA;&#xA;  dia = 216/200;--// GetProjectData('Диаметр'); // как вариант не создавать в &quot;Установках&quot; а создать директорию? файл? проект&#xA;&#xA;  if t.Rbf.A.XY == ''  then &#xA;    return;&#xA;  end&#xA;  --//if not XmlPathExists(t, 'RUN') then Exit;&#xA;&#xA;  if v['нк1'].DEV.VALUE == 0 then &#xA;     k1 = t.KW1 &#xA;  else &#xA;     k1 = t.KW1 / v['нк1'].DEV.VALUE;&#xA;  end &#xA;&#xA;  if v['нк2'].DEV.VALUE == 0 then &#xA;    k2 = t.KW2 &#xA;  else &#xA;    k2 = t.KW2 / v['нк2'].DEV.VALUE;&#xA;  end&#xA;&#xA;  if k1 == 0 then &#xA;    dv = k2 &#xA;   else &#xA;    dv = k2/k1;&#xA;  end;&#xA;				--run_path ='WRK'&#xA;  local f, p = FindXmlRoot(v, run_path, 'ГК')&#xA;  if f and (v['нгк'].CLC.VALUE &gt; p['гк'].CLC.VALUE) then&#xA;     kg = t.KWG/ (v['нгк'].CLC.VALUE - p['гк'].CLC.VALUE) * t.kNGK;&#xA;  elseif v['нгк'].CLC.VALUE == 0 then&#xA;     kg = t.KWG&#xA;  else&#xA;     kg = t.KWG/v['нгк'].CLC.VALUE * t.kNGK;&#xA;  end&#xA;&#xA;  v['Кп'].CLC.VALUE = RbfInterp(t.Rbf.A, dia, dv);&#xA;  v['Кпг'].CLC.VALUE = RbfInterp(t.Rbf.G, dia, kg);&#xA;  v['Кпм'].CLC.VALUE = RbfInterp(t.Rbf.K1, dia, k1);&#xA;  v['Кпб'].CLC.VALUE = RbfInterp(t.Rbf.K2, dia, k2);&#xA;--]]&#xA;--end;&#xA;" SETUP_METR="-- var&#xA;--  m: variant;&#xA;--begin&#xA; --[[ AddXmlPath(v, 'Кп');&#xA;  AddXmlPath(v, 'Кпм');&#xA;  AddXmlPath(v, 'Кпб');&#xA;  AddXmlPath(v, 'Кпг');&#xA;--  // переменная вводится вручную или саздать в проекте?&#xA;  AddXmlPath(v, 'Диаметр');&#xA;&#xA;--// Форматирование и вычисляемые параметры&#xA;--//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m = AddMetrology(v['нгк'], 'нгк', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кп'], 'Кп', '%', 1.1);&#xA;  AddMetrologyFM(m, 1, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кпм'], 'Кпм', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кпб'], 'Кпб', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Кпг'], 'Кпг', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, 0xFFFF0000);&#xA;&#xA;  m = AddMetrology(v['Диаметр'], 'Диаметр', 'мм', 1.1);&#xA;  AddMetrologyFM(m, 8, 0);&#xA;&#xA;  v['Диаметр'].CLC.VALUE = 216;&#xA;&#xA;--//  AddXmlPath(v, 'Диаметр');&#xA;--//  AddMetrology(v.Диаметр, 'мм.', '%1.0f', 0, 400);&#xA;--//  v.Диаметр.CLC.VALUE := 216;&#xA;--//  DivArray(t.нк1,  t.нк2,  t.нк);&#xA;--]]&#xA;--end;&#xA;&#xA;"><IMPORT/>
				<EXPORT/>
			</NNK2X1></MODEL>
		<TRR_MODEL>
			<TNNK2X EXEC_METR="&#xA;--var&#xA;--  k, k1, k2, kg: Double;&#xA;&#xA;function execute_step(stp, alg, trr)&#xA;&#xA;-- var&#xA;--  st: variant;&#xA;--  i: Integer;&#xA;--  dia, xy, xy1, xy2, xyg: string;&#xA;&#xA;--[[FindPoint = function()&#xA;    if st['нк2'].DEV.VALUE == 0 then st.nkw = k * st['нк1'].DEV.VALUE else st.nkw = k * st['нк1'].DEV.VALUE/st['нк2'].DEV.VALUE end;&#xA;    if st['нк1'].DEV.VALUE == 0 then st.nkw1 = k1 else st.nkw1 = k1/st['нк1'].DEV.VALUE end;&#xA;    if st['нк2'].DEV.VALUE == 0 then st.nkw2 = k2 else st.nkw2 = k2/st['нк2'].DEV.VALUE end;&#xA;    if st['нгк'].DEV.VALUE == 0 then st.nkwg = kg else st.nkwg = kg/st['нгк'].DEV.VALUE end;&#xA;  end;&#xA;&#xA;   st = AddXmlPath(alg, 'STEP'..stp);&#xA;&#xA;   if stp == 1 then  --case stp of&#xA;   --1: begin&#xA;        k1 = st['нк1'].DEV.VALUE;&#xA;        k2 = st['нк2'].DEV.VALUE;&#xA;        kg = st['нгк'].DEV.VALUE;&#xA;        if k1 == 0 then k = k2 else k = k2/k1 end;&#xA;        FindPoint();&#xA;   elseif stp == 14 then&#xA;       -- 14: begin&#xA;        k1 = (alg.STEP1['нк1'].DEV.VALUE + alg.STEP11['нк1'].DEV.VALUE)/2;&#xA;        k2 = (alg.STEP1['нк2'].DEV.VALUE + alg.STEP11['нк2'].DEV.VALUE)/2;&#xA;        kg = (alg.STEP1['нгк'].DEV.VALUE + alg.STEP11['нгк'].DEV.VALUE)/2;&#xA;        if k1 == 0 then k = k2 else k = k2/k1 end;&#xA;        --// коэфф полученн при тарировке&#xA;        trr.KW1 = k1;&#xA;        trr.KW2 = k2;&#xA;        --//trr.KW := k; лишнее&#xA;        trr.KWG = kg;&#xA;        local xy = '[';  local xy1 = '['; local xy2 = '['; local xyg = '[';&#xA;        for i = 1,14 do&#xA;         --begin&#xA;          st = AddXmlPath(alg, 'STEP'..i);&#xA;          FindPoint();&#xA;          if (i ~= 1) and (i ~= 11) then&#xA;   dia = st.D/200;&#xA;   xy  = xy ..'['..dia..','..st.nkw..','..st.KP..']';&#xA;   xy1 = xy1..'['..dia..','..st.nkw1..','..st.KP..']';&#xA;   xy2 = xy2..'['..dia..','..st.nkw2..','..st.KP..']';&#xA;   xyg = xyg..'['..dia..','..st.nkwg..','..st.KP..']';&#xA;   if i == 14 then &#xA;                xy = xy..']'; &#xA;    xy1 = xy1..']'            &#xA;    xy2 = xy2..']'&#xA;    xyg = xyg..']' &#xA;   else &#xA;    xy  = xy..','; &#xA;    xy1 = xy1..', ' &#xA;    xy2 = xy2..',' &#xA;    xyg = xyg..',' &#xA;            end;&#xA;          end;&#xA;    st = AddXmlPath(trr, 'Rbf.A'); st.XY = xy;&#xA;          st = AddXmlPath(trr, 'Rbf.K1'); st.XY = xy1;&#xA;          st = AddXmlPath(trr, 'Rbf.K2'); st.XY = xy2;&#xA;          st = AddXmlPath(trr, 'Rbf.G'); st.XY = xyg;&#xA;        end       &#xA;   else &#xA;        FindPoint();&#xA;   end--]]&#xA;end&#xA;&#xA;" SETUP_METR="--var&#xA;local W = {&#xA;			{124, {'Вода', '0.6', '18.2', '36.5'}},&#xA;			{156, {'0.7', '18.2', '36.5'}},&#xA;			{216, {'0.7', '18.2', '36.5'}},&#xA;		};&#xA;local Z = {'BL','BR','DL','DR'}&#xA;	&#xA;local InitStep = function (stp, d, model, lr)&#xA;&#xA;    local s = AddXmlPath(t, 'STEP'..stp);&#xA;&#xA;    s.EXECUTED = false;&#xA;    s.STEP = stp;&#xA;	s.KP = model;&#xA;	s.D = d;&#xA;	s.LR = lr;&#xA;    s.INFO = 'Шаг: '..stp..'  Диаметр: '..d..'  модель: '..model..'  Прижимать: '..s.LR; &#xA;&#xA;	local AddDevClc = function (name)&#xA;		local r = AddXmlPath(s, name)&#xA;		AddXmlPath(r,'CLC');&#xA;		AddXmlPath(r,'DEV');&#xA;		r.CLC.VALUE = 0;&#xA;		r.DEV.VALUE = 0;&#xA;	end&#xA;&#xA;	for _,z in next, Z do&#xA;		AddDevClc(z)&#xA;	end		&#xA;    return s;&#xA;end&#xA;--begin&#xA;	local step = 1&#xA;	for _, val in next, W do&#xA;        local d = val[1];&#xA;       -- DebugLog('for d, m in next, W do', ' STEP:', step, 'D:', d, 'MODEL', val[2]);&#xA;		for _, model in next, val[2] do&#xA;			--DebugLog('     for _, model in next, m do', ' STEP:', step, ' mkey:',  mkey, 'MODEL', model);&#xA;			InitStep(step,d,model,'Левый')&#xA;			step = step + 1&#xA;			InitStep(step,d,model,'Правый')&#xA;			step = step + 1&#xA;		end&#xA;	end&#xA;t.STEP1.ATT_COUNT = t.AttCount_Voda;&#xA;t.STEP2.ATT_COUNT = t.AttCount_Voda;&#xA; --end;&#xA;&#xA;"><IMPORT/>
				<EXPORT EXPORT0="&#xA;function GetFilterName()&#xA;&#xA;  return 'Экспортирование в LibireOffice Calc(*.ods)|*.ods';&#xA;end&#xA;&#xA;function OnExecuteFilter(TrrFile, NewTrr)&#xA;-- //  унифицированная процепура осздания отчета&#xA;-- //       TrrFile -- файл тарировки&#xA;-- //       NewTrr -- источник данных&#xA;-- //       'ReportNNK1.ods' -- шаблон в Devices&#xA;-- //       'ReportNNK1.xml' -- инструкция по заполнению полей шаблона в Devices&#xA;  ExportToCalc('ReportNNK2X.ods', 'ReportNNK2X.xml', TrrFile, NewTrr);&#xA;end&#xA;"/>
			</TNNK2X></TRR_MODEL>
	</NNK2X></TRR>
