<?xml version="1.0" encoding="utf-8"?>
<TRR>
	<SIMPLE_FORMAT>
		<MODEL>
			<D3A EXEC_METR="{ procedure (v, t: variant);&#xA;  где t - корневой элемент метрологии модуля&#xA;  v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  v.T.CLC.VALUE := v.T.DEV.VALUE/4;&#xA;  v.X.CLC.VALUE := v.X.DEV.VALUE*1000;&#xA;  v.Y.CLC.VALUE := v.Y.DEV.VALUE*1000;&#xA;  v.Z.CLC.VALUE := v.Z.DEV.VALUE*1000;&#xA;end;&#xA;" SETUP_METR="{ procedure (v, t: variant);&#xA;  где t - корневой элемент метрологии модуля&#xA;  v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  AddMetrology(v.T, '°C', '%8.1f',  -40, 150);&#xA;&#xA;  AddMetrology(v.X, 'mG', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.Y, 'mG', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.Z, 'mG', '%8.1f',  -1000, 1000);&#xA;end;&#xA;"/>
			<D3H EXEC_METR="{ procedure (v, t: variant);&#xA;  где t - корневой элемент метрологии модуля&#xA;  v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  v.T.CLC.VALUE := v.T.DEV.VALUE/4;&#xA;  v.X.CLC.VALUE := v.X.DEV.VALUE*1000;&#xA;  v.Y.CLC.VALUE := v.Y.DEV.VALUE*1000;&#xA;  v.Z.CLC.VALUE := v.Z.DEV.VALUE*1000;&#xA;end;&#xA;" SETUP_METR="{ procedure (v, t: variant);&#xA;  где t - корневой элемент метрологии модуля&#xA;  v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  AddMetrology(v.T, '°C', '%8.1f',  -40, 150);&#xA;&#xA;  AddMetrology(v.X, '', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.Y, '', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.Z, '', '%8.1f',  -1000, 1000);&#xA;end;&#xA;"/>
			<AU EXEC_METR="{ procedure (v, t: variant);&#xA;  где t - корневой элемент метрологии модуля&#xA;  v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; var&#xA;  s: string;&#xA;  au: Integer;&#xA;begin&#xA;{   APP_SET_TIME,&#xA; APP_CLEAR_RAM,&#xA; APP_DELAY,&#xA; APP_WORK,&#xA; APP_IDLE,}&#xA;&#xA;    au := v.DEV.VALUE;&#xA;&#xA;    case (au and $0F) of&#xA;     0: s := 'Установка времени';&#xA;     1: s := 'Стирание памяти';&#xA;     2: s := 'Задержка';&#xA;     3: s := 'Работа';&#xA;     4: s := 'Выключен';&#xA;     else s := 'Ошибка !!!'&#xA;    end;&#xA;&#xA;    if (au and $80) &lt;&gt; 0 then s := s + ' [контроль]';&#xA;&#xA;    v.CLC.VALUE := s;&#xA;end;&#xA;" SETUP_METR="{ procedure (v: variant);&#xA;  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  AddXmlPath(v, 'CLC');&#xA;  v.CLC.VALUE := 'Нет Данных';&#xA;  v.CLC.TYPE := varString;&#xA;end;&#xA;"></AU>
			<WT_USO_PSK EXEC_METR="{ procedure (v, t: variant);&#xA;  где t - корневой элемент метрологии модуля&#xA;  v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  v.CLC.VALUE := VarAsType(-v.DEV.VALUE*2.097152/2/3600/24, varDate);&#xA;end;&#xA;" SETUP_METR="{ procedure (v: variant);&#xA;  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  AddXmlPath(v, 'CLC');&#xA;  v.CLC.VALUE := VarAsType(Now(), varDate);&#xA;  v.CLC.TYPE := varDate;&#xA;end;&#xA;"></WT_USO_PSK>
			<WT_GLU_PSK EXEC_METR="{ procedure (v, t: variant);&#xA;  где t - корневой элемент метрологии модуля&#xA;  v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  v.CLC.VALUE := VarAsType(v.DEV.VALUE*2.097152/2/3600/24, varDate);&#xA;end;&#xA;" SETUP_METR="{ procedure (v: variant);&#xA;  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  AddXmlPath(v, 'CLC');&#xA;  v.CLC.VALUE := VarAsType(Now(), varDate);&#xA;  v.CLC.TYPE := varDate;&#xA;end;&#xA;"/>
			<WT EXEC_METR="{ procedure (v, t: variant);&#xA;  где t - корневой элемент метрологии модуля&#xA;  v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  v.CLC.VALUE := KadrToStr(v.DEV.VALUE);&#xA;end;&#xA;" SETUP_METR="{ procedure (v: variant);&#xA;  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  AddXmlPath(v, 'CLC');&#xA;   v.CLC.VALUE := '0';&#xA;   v.CLC.TYPE := varString;&#xA;end;&#xA;"></WT>
			<D3TM EXEC_METR="{ procedure (v, t: variant);&#xA;  где t - корневой элемент метрологии модуля&#xA;  v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  v.CLC.VALUE := VarAsType(v.DEV.VALUE/3600/24/64, varDate);&#xA;end;&#xA;" SETUP_METR="{ procedure (v: variant);&#xA;  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  AddXmlPath(v, 'CLC');&#xA;  v.CLC.VALUE := VarAsType(Now(), varDate);&#xA;  v.CLC.TYPE := varDate;&#xA;end;&#xA;"></D3TM>
			<D3TM1 EXEC_METR="{ procedure (v, t: variant);&#xA;  где t - корневой элемент метрологии модуля&#xA;  v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  v.CLC.VALUE := VarAsType(v.DEV.VALUE/3600/24/64, varDate);&#xA;end;&#xA;" SETUP_METR="{ procedure (v: variant);&#xA;  v - корневой элемент метрологии модуля или данных модуля (режим информации)&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  AddXmlPath(v, 'CLC');&#xA;  v.CLC.VALUE := VarAsType(Now(), varDate);&#xA;  v.CLC.TYPE := varDate;&#xA;end;&#xA;"/>
		</MODEL>
	</SIMPLE_FORMAT>
	<Inclin SETUP_METR="begin&#xA;//  тип создание ветви поправкок и заполнение значениями по умолчанию&#xA;// косоугольность, смещение 0 амплит. акселер.&#xA;  AddXmlPath(t, 'accel');&#xA;  AddXmlMatrix(t.accel, 3,4);&#xA;// по умолранию амплит=1 остальнвые 0&#xA;  t.accel.m3x4.m11 := 1;&#xA;  t.accel.m3x4.m22 := 1;&#xA;  t.accel.m3x4.m33 := 1;&#xA;// косоугольность, смещение 0 амплит. магнит.&#xA;  AddXmlPath(t, 'magnit');&#xA;  AddXmlMatrix(t.magnit, 3,4);&#xA;// по умолранию амплит=1 остальнвые 0&#xA;  t.magnit.m3x4.m11 := 1;&#xA;  t.magnit.m3x4.m22 := 1;&#xA;  t.magnit.m3x4.m33 := 1;&#xA;end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<D3 EXEC_METR="{ procedure ( v, t: variant);&#xA;  t - корневой элемент метрологии&#xA;  где v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; var&#xA;  os,oc,zs,zc,&#xA;  a, zu, o, mo, b,&#xA;  x,y,z, Hx, Hy, Hz: Double;&#xA;  res: Variant;&#xA;begin&#xA;// получение тарированных данных&#xA;// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;// - четвертая размерность V[4].ROW=1&#xA;// ROW- атрибут сырые данные с прибора&#xA;  TrrVect3D(t.accel.m3x4, v.accel);//, 1000);&#xA;  x := v.accel.X.CLC.VALUE;&#xA;  y := v.accel.Y.CLC.VALUE;&#xA;  z := v.accel.Z.CLC.VALUE;&#xA;  v.амплит_accel.CLC.VALUE := Hypot3D(x, y, z);&#xA;&#xA;  o := Arctan2(y, -x);&#xA;  zu := Arctan2(Hypot(x, y), z);&#xA;&#xA;  TrrVect3D(t.magnit.m3x4, v.magnit);//, 1000);&#xA;  x := v.magnit.X.CLC.VALUE;&#xA;  y := v.magnit.Y.CLC.VALUE;&#xA;  z := v.magnit.Z.CLC.VALUE;&#xA;  v.амплит_magnit.CLC.VALUE := Hypot3D(x, y, z);&#xA;&#xA;  mo := Arctan2(y, -x);&#xA;&#xA;  os := sin(o);&#xA;  oc := cos(o);&#xA;  zs := sin(zu);&#xA;  zc := cos(zu);&#xA;&#xA;  Hx := (x*oc - y*os)*zc + z*zs;&#xA;  Hy :=  x*os + y*oc;&#xA;  Hz :=-(x*oc - y*os)*zs + z*zc;&#xA;&#xA;  a := -Arctan2(Hy, Hx);&#xA;  b := Arctan2(Hypot(Hx, Hy), Hz);&#xA;&#xA;  v.зенит.CLC.VALUE       := RadToDeg_0_180(zu);&#xA;  v.азимут.CLC.VALUE      := RadToDeg_0_360(a);&#xA;  v.отклонитель.CLC.VALUE := RadToDeg_0_360(o);&#xA;  v.маг_отклон.CLC.VALUE  := RadToDeg_0_360(mo);&#xA;  v.маг_наклон.CLC.VALUE  := RadToDeg_0_360(b);&#xA;end;&#xA;" SETUP_METR=" var&#xA;  m: variant;&#xA;begin&#xA;// Форматирование и вычисляемые параметры&#xA;//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m := AddMetrology(v.accel.X, 'AX', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FFFF0000, 3, 1);&#xA;&#xA;  m := AddMetrology(v.accel.Y, 'AY', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FF00FF00, 3, 1);&#xA;&#xA;  m := AddMetrology(v.accel.Z, 'AZ', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FF0000FF, 3, 1);&#xA;&#xA;  m := AddMetrology(v.accel.X.DEV, 'ax', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, $808F0000, 1, 1);&#xA;  m := AddMetrology(v.accel.Y.DEV, 'ay', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, $80008F00, 1, 1);&#xA;  m := AddMetrology(v.accel.Z.DEV, 'az', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, $8000008F, 1, 1);&#xA;&#xA;  m := AddMetrology(v.magnit.X, 'HX', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FF800000);&#xA;&#xA;  m := AddMetrology(v.magnit.Y, 'HY', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FF008000);&#xA;&#xA;  m := AddMetrology(v.magnit.Z, 'HZ', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FF000080);&#xA;&#xA;  m := AddMetrology(v.magnit.X.DEV, 'hx', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $80804000, 1, 1);&#xA;  m := AddMetrology(v.magnit.Y.DEV, 'hy', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $80408000, 1, 1);&#xA;  m := AddMetrology(v.magnit.Z.DEV, 'hz', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $80004080, 1, 1);&#xA;&#xA;  // вычисляемые параметры&#xA;  AddXmlPath(v, 'зенит');&#xA;  v.зенит.METR := 'ANGLE';&#xA;  m := AddMetrology(v.зенит, 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, $C0800080, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'азимут');&#xA;  v.азимут.METR := 'ANGLE';&#xA;  m := AddMetrology(v.азимут, 'азимут', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, $C0800000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'отклонитель');&#xA;  v.отклонитель.METR := 'ANGLE';&#xA;  m := AddMetrology(v.отклонитель, 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, $C0404000, 2, 1);&#xA;&#xA;  AddXmlPath(v, 'маг_отклон');&#xA;  v.маг_отклон.METR := 'ANGLE';&#xA;  m := AddMetrology(v.маг_отклон, 'маг.визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, $C0303000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'маг_наклон');&#xA;  v.маг_наклон.METR := 'ANGLE';&#xA;  m := AddMetrology(v.маг_наклон, 'маг.наклон', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, $C0804000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'амплит_accel');&#xA;  m := AddMetrology(v.амплит_accel, 'A', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, $C0408000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'амплит_magnit');&#xA;  m := AddMetrology(v.амплит_magnit, 'H', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, $C0404080, 2, 2);&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</D3>
			<DPSK EXEC_METR="{ procedure ( v, t: variant);&#xA;  t - корневой элемент метрологии&#xA;  где v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; var&#xA;  os,oc,zs,zc,&#xA;  a, zu, o, mo, b,&#xA;  x,y,z, Hx, Hy, Hz: Double;&#xA;  res: Variant;&#xA;begin&#xA;// получение тарированных данных&#xA;// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;// - четвертая размерность V[4].ROW=1&#xA;// ROW- атрибут сырые данные с прибора&#xA;  TrrVect3D(t.accel.m3x4, v.accel);//, 1000);&#xA;  x := v.accel.X.CLC.VALUE;&#xA;  y := v.accel.Y.CLC.VALUE;&#xA;  z := v.accel.Z.CLC.VALUE;&#xA;  v.амплит_accel.CLC.VALUE := Hypot3D(x, y, z);&#xA;&#xA;  o := Arctan2(y, -x);&#xA;  zu := Arctan2(Hypot(x, y), z);&#xA;&#xA;  TrrVect3D(t.magnit.m3x4, v.magnit);//, 1000);&#xA;  x := v.magnit.X.CLC.VALUE;&#xA;  y := v.magnit.Y.CLC.VALUE;&#xA;  z := v.magnit.Z.CLC.VALUE;&#xA;  v.амплит_magnit.CLC.VALUE := Hypot3D(x, y, z);&#xA;&#xA;  mo := Arctan2(y, -x);&#xA;&#xA;  os := sin(o);&#xA;  oc := cos(o);&#xA;  zs := sin(zu);&#xA;  zc := cos(zu);&#xA;&#xA;  Hx := (x*oc - y*os)*zc + z*zs;&#xA;  Hy :=  x*os + y*oc;&#xA;  Hz :=-(x*oc - y*os)*zs + z*zc;&#xA;&#xA;  a := -Arctan2(Hy, Hx);&#xA;  b := Arctan2(Hypot(Hx, Hy), Hz);&#xA;&#xA;  v.зенит.CLC.VALUE       := RadToDeg_0_180(zu);&#xA;  v.азимут.CLC.VALUE      := RadToDeg_0_360(a);&#xA;  v.отклонитель.CLC.VALUE := RadToDeg_0_360(o);&#xA;  v.маг_отклон.CLC.VALUE  := RadToDeg_0_360(mo);&#xA;  v.маг_наклон.CLC.VALUE  := RadToDeg_0_360(b);&#xA;end;&#xA;" SETUP_METR=" var&#xA;  m: variant;&#xA;begin&#xA;// Форматирование и вычисляемые параметры&#xA;//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m := AddMetrology(v.accel.X, 'AX', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FFFF0000, 3, 1);&#xA;&#xA;  m := AddMetrology(v.accel.Y, 'AY', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FF00FF00, 3, 1);&#xA;&#xA;  m := AddMetrology(v.accel.Z, 'AZ', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FF0000FF, 3, 1);&#xA;&#xA;  m := AddMetrology(v.accel.X.DEV, 'ax', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, $808F0000, 1, 1);&#xA;  m := AddMetrology(v.accel.Y.DEV, 'ay', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, $80008F00, 1, 1);&#xA;  m := AddMetrology(v.accel.Z.DEV, 'az', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -7000, 7000);&#xA;  AddMetrologyCL(m, $8000008F, 1, 1);&#xA;&#xA;  m := AddMetrology(v.magnit.X, 'HX', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FF800000);&#xA;&#xA;  m := AddMetrology(v.magnit.Y, 'HY', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FF008000);&#xA;&#xA;  m := AddMetrology(v.magnit.Z, 'HZ', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $FF000080);&#xA;&#xA;  m := AddMetrology(v.magnit.X.DEV, 'hx', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $80804000, 1, 1);&#xA;  m := AddMetrology(v.magnit.Y.DEV, 'hy', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $80408000, 1, 1);&#xA;  m := AddMetrology(v.magnit.Z.DEV, 'hz', '');&#xA;  AddMetrologyFM(m, 7, 0);&#xA;  AddMetrologyRG(m, -1000, 1000);&#xA;  AddMetrologyCL(m, $80004080, 1, 1);&#xA;&#xA;  // вычисляемые параметры&#xA;  AddXmlPath(v, 'зенит');&#xA;  v.зенит.METR := 'ANGLE';&#xA;  m := AddMetrology(v.зенит, 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, $C0800080, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'азимут');&#xA;  v.азимут.METR := 'ANGLE';&#xA;  m := AddMetrology(v.азимут, 'азимут', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, $C0800000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'отклонитель');&#xA;  v.отклонитель.METR := 'ANGLE';&#xA;  m := AddMetrology(v.отклонитель, 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, $C0404000, 2, 1);&#xA;&#xA;  AddXmlPath(v, 'маг_отклон');&#xA;  v.маг_отклон.METR := 'ANGLE';&#xA;  m := AddMetrology(v.маг_отклон, 'маг.визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, $C0303000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'маг_наклон');&#xA;  v.маг_наклон.METR := 'ANGLE';&#xA;  m := AddMetrology(v.маг_наклон, 'маг.наклон', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, $C0804000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'амплит_accel');&#xA;  m := AddMetrology(v.амплит_accel, 'A', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, $C0408000, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'амплит_magnit');&#xA;  m := AddMetrology(v.амплит_magnit, 'H', 'mT');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, $C0404080, 2, 2);&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</DPSK>
			<DPSK_old EXEC_METR="{ procedure ( v, t: variant);&#xA;  t - корневой элемент метрологии&#xA;  где v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; var&#xA;  os,oc,zs,zc,&#xA;  a, zu, o, mo, b,&#xA;  x,y,z: Double;&#xA;  res: Variant;&#xA;begin&#xA;// получение тарированных данных&#xA;// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;// - четвертая размерность V[4].ROW=1&#xA;// ROW- атрибут сырые данные с прибора&#xA;  TrrVect3D(t.accel.m3x4, v.accel);//, 1000);&#xA;  x := v.accel.X.TRR;&#xA;  y := v.accel.Y.TRR;&#xA;  z := v.accel.Z.TRR;&#xA;  v.амплит_accel.TRR := Hypot3D(x, y, z);&#xA;&#xA;  o := Arctan2(y, x);&#xA;  zu := Arctan2(z, Hypot(x, y));&#xA;&#xA;  TrrVect3D(t.magnit.m3x4, v.magnit);//, 1000);&#xA;  x := v.magnit.X.TRR;&#xA;  y := v.magnit.Y.TRR;&#xA;  z := v.magnit.Z.TRR;&#xA;  v.амплит_magnit.TRR := Hypot3D(x, y, z);&#xA;&#xA;  mo := Arctan2(y, x);&#xA;&#xA;  os := sin(o);&#xA;  oc := cos(o);&#xA;  zs := sin(zu);&#xA;  zc := cos(zu);&#xA;&#xA;  a := Arctan2(x*os + y*oc, (x*oc - y*oc)*zc - z*zs);&#xA;&#xA;  b := Arctan2(x*os + y*oc, (x*oc - y*oc)*zc - z*zs);&#xA;&#xA;  v.зенит.TRR       := RadToDeg_0_180(zu);&#xA;  v.азимут.TRR      := RadToDeg_0_360(a);&#xA;  v.отклонитель.TRR := RadToDeg_0_360(o);&#xA;  v.маг_отклон.TRR  := RadToDeg_0_360(mo);&#xA;  v.маг_наклон.TRR  := RadToDeg_0_360(b);&#xA;end;&#xA;" SETUP_METR="begin&#xA;// Форматирование и вычисляемые параметры&#xA;  AddMetrology(v.accel.X, '', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.accel.Y, '', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.accel.Z, '', '%8.1f',  -1000, 1000);&#xA;&#xA;  AddMetrology(v.magnit.X, '', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.magnit.Y, '', '%8.1f',  -1000, 1000);&#xA;  AddMetrology(v.magnit.Z, '', '%8.1f',  -1000, 1000);&#xA;&#xA;  // вычисляемые параметры&#xA;  AddXmlPath(v, 'зенит');&#xA;  AddMetrology(v.зенит, 'град.', '%8.2f',  0, 180);&#xA;&#xA;  AddXmlPath(v, 'азимут');&#xA;  AddMetrology(v.азимут, 'град.', '%8.1f',  0, 360);&#xA;&#xA;  AddXmlPath(v, 'отклонитель');&#xA;  AddMetrology(v.отклонитель, 'град.', '%8.1f',  0, 360);&#xA;&#xA;  AddXmlPath(v, 'маг_отклон');&#xA;  AddMetrology(v.маг_отклон, 'град.', '%8.1f',  0, 360);&#xA;&#xA;  AddXmlPath(v, 'маг_наклон');&#xA;  AddMetrology(v.маг_наклон, 'град.', '%8.1f',  0, 360);&#xA;&#xA;  AddXmlPath(v, 'амплит_accel');&#xA;  AddMetrology(v.амплит_accel, '', '%8.3f',  0, 1000);&#xA;&#xA;  AddXmlPath(v, 'амплит_magnit');&#xA;  AddMetrology(v.амплит_magnit, '', '%8.3f',  0, 1000);&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</DPSK_old>
			<T21 EXEC_METR="&#xA;var&#xA; GXmax, GXmin, Sgx, Kgx: Double; // точки 1,2&#xA; GYmax, GYmin, Sgy, Kgy: Double; // точки 3,4&#xA; GZmax, GZmin, Sgz, Kgz: Double; // точки 5,6&#xA;&#xA; Gxp3, Gyp3, Gzp3: Double; // используем точку 6&#xA; Gxp1, Gyp1, Gzp1: Double; // точкa 7&#xA; Gxp2, Gyp2, Gzp2: Double; // точкa 8&#xA;&#xA; Axy, Axz, Ayz, Azx, Azy: Double; // косоугольность акселерометров&#xA;&#xA; HXmax, HXmin, Shx, Khx: Double; // точки 9,10&#xA; HYmax, HYmin, Shy, Khy: Double; // точки 11,12&#xA; HZmax, HZmin, Shz, Khz: Double; // точки 13,14&#xA;&#xA; Bxy, Bxz, Byx, Byz, Bzx, Bzy: Double; // косоугольность магнитометров&#xA;// Zen = 90&#xA; Hxp1, Hyp1, Hzp1: Double; // точкa 15 Azi := 0; otk = 0;&#xA; Hxp2, Hyp2, Hzp2: Double; // точкa 16 Azi := 0; otk = 90;&#xA; Hxp3, Hyp3, Hzp3: Double; // точкa 17 Azi := 0; otk = 180;&#xA; Hxp4, Hyp4, Hzp4: Double; // точкa 18 Azi := 0; otk = 270;&#xA; Hxp5, Hyp5, Hzp5: Double; // точкa 19 Azi := 90; otk = 0;&#xA; Hxp6, Hyp6, Hzp6: Double; // точкa 20 Azi := 90; otk = 90; // по мет. Azi := 270; otk = 0;&#xA;&#xA;procedure execute_step(stp: integer; alg, trr: variant);&#xA; var&#xA;  AlgStep: variant;&#xA;  c,h: Double;&#xA;&#xA;  procedure FindPAcc(var Xp, Yp, Zp: Double);&#xA;  begin&#xA;    Xp := AlgStep.accel.X.CLC.VALUE;&#xA;    Yp := AlgStep.accel.Y.CLC.VALUE;&#xA;    Zp := AlgStep.accel.Z.CLC.VALUE;&#xA;  end;&#xA;&#xA;  procedure FindPMag(var Xp, Yp, Zp: Double);&#xA;  begin&#xA;    // *** test ****&#xA;    TrrVect3D(trr.magnit.m3x4, AlgStep.magnit);//, 1000);&#xA;&#xA;    Xp := AlgStep.magnit.X.CLC.VALUE;&#xA;    Yp := AlgStep.magnit.Y.CLC.VALUE;&#xA;    Zp := AlgStep.magnit.Z.CLC.VALUE;&#xA;  end;&#xA;&#xA;  procedure FindSxxKxx(mx, mn: Double; var Sxx, Kxx: Double);&#xA;  begin&#xA;    Sxx := (mx + mn)/2;&#xA;    Kxx := (mx - mn)/2;&#xA;  end;&#xA;begin&#xA;  AlgStep := AddXmlPath(alg, 'STEP' + IntToStr(stp));&#xA;&#xA;  case stp of&#xA;// акселерометры&#xA;   1: GXmin := AlgStep.accel.X.DEV.VALUE;&#xA;   2: GXmax := AlgStep.accel.X.DEV.VALUE;&#xA;   3: GYmin := AlgStep.accel.Y.DEV.VALUE;&#xA;   4: GYmax := AlgStep.accel.Y.DEV.VALUE;&#xA;   5: GZmin := AlgStep.accel.Z.DEV.VALUE;&#xA;   6: begin&#xA;       GZmax := AlgStep.accel.Z.DEV.VALUE;&#xA;       // действия по методике&#xA;       FindSxxKxx(GXmax, GXmin, Sgx, Kgx);&#xA;       FindSxxKxx(GYmax, GYmin, Sgy, Kgy);&#xA;       FindSxxKxx(GZmax, GZmin, Sgz, Kgz);&#xA;&#xA;       Kgx := Kgx/Kgy;&#xA;       Kgz := Kgz/Kgy;&#xA;       Kgy := 1;&#xA;       // переводим поправки по метидикe в стандартные&#xA;       // обновляем буржуйскую таблицу поправок&#xA;       trr.accel.m3x4.m14 := -Sgx/Kgx;&#xA;       trr.accel.m3x4.m24 := -Sgy/Kgy;&#xA;       trr.accel.m3x4.m34 := -Sgz/Kgz;&#xA;&#xA;       trr.accel.m3x4.m11 := 1/Kgx;&#xA;       trr.accel.m3x4.m22 := 1/Kgy;&#xA;       trr.accel.m3x4.m33 := 1/Kgz;&#xA;       // пересчитываем данные TRR для текущего шага&#xA;       TrrVect3D(trr.accel.m3x4, AlgStep.accel);&#xA;       // действия по методике&#xA;       FindPAcc(Gxp3, Gyp3, Gzp3);&#xA;      end;&#xA;   7: FindPAcc(Gxp1, Gyp1, Gzp1);&#xA;   8: begin&#xA;       FindPAcc(Gxp2, Gyp2, Gzp2);&#xA;       // действия по методике&#xA;       Axy := Gxp2/Gyp2;&#xA;       Axz := -Gxp3/Gzp3;&#xA;       Ayz := Gyp3/Gzp3;&#xA;       Azx := Gzp1/Gxp1;&#xA;       Azy := -Gzp2/Gyp2;&#xA;       // переводим поправки по метидикe в стандартные&#xA;       // обновляем буржуйскую таблицу поправок&#xA;       trr.accel.m3x4.m12 := -Axy/Kgx;&#xA;       trr.accel.m3x4.m13 :=  Axz/Kgx;&#xA;&#xA;       trr.accel.m3x4.m23 := -Ayz/Kgy;&#xA;&#xA;       trr.accel.m3x4.m31 := -Azx/Kgz;&#xA;       trr.accel.m3x4.m32 :=  Azy/Kgz;&#xA;      end;&#xA;//  магнитометры&#xA;   9: HXmin := AlgStep.magnit.X.DEV.VALUE;&#xA;  10: HXmax := AlgStep.magnit.X.DEV.VALUE;&#xA;  11: HYmin := AlgStep.magnit.Y.DEV.VALUE;&#xA;  12: HYmax := AlgStep.magnit.Y.DEV.VALUE;&#xA;  13: HZmin := AlgStep.magnit.Z.DEV.VALUE;&#xA;  14: begin&#xA;       HZmax := AlgStep.magnit.Z.DEV.VALUE;&#xA;&#xA;       FindSxxKxx(HXmax, HXmin, Shx, Khx);&#xA;       FindSxxKxx(HYmax, HYmin, Shy, Khy);&#xA;       FindSxxKxx(HZmax, HZmin, Shz, Khz);&#xA;&#xA;       Khx := Khx/Khy;&#xA;       Khz := Khz/Khy;&#xA;       Khy := 1;&#xA;&#xA;       trr.magnit.m3x4.m14 := -Shx/Khx;&#xA;       trr.magnit.m3x4.m24 := -Shy/Khy;&#xA;       trr.magnit.m3x4.m34 := -Shz/Khz;&#xA;&#xA;       trr.magnit.m3x4.m11 := 1/Khx;&#xA;       trr.magnit.m3x4.m22 := 1/Khy;&#xA;       trr.magnit.m3x4.m33 := 1/Khz;&#xA;      end;&#xA;  15: FindPMag(Hxp1, Hyp1, Hzp1);&#xA;  16: FindPMag(Hxp2, Hyp2, Hzp2);&#xA;  17: FindPMag(Hxp3, Hyp3, Hzp3);&#xA;  18: FindPMag(Hxp4, Hyp4, Hzp4);&#xA;  19: FindPMag(Hxp5, Hyp5, Hzp5);&#xA;  20: begin&#xA;       FindPMag(Hxp6, Hyp6, Hzp6);&#xA;&#xA;       Byx :=  (Hyp1 - Hyp3)/(Hxp3 - Hxp1);&#xA;       Byz :=  (Hyp1 + Hyp3)/(Hzp1 + Hzp3);&#xA;&#xA;       Bxy :=  (Hxp2 - Hxp4)/(Hyp2 - Hyp4);&#xA;       Bxz := -(Hxp2 + Hxp4)/(Hzp2 + Hzp4);&#xA;&#xA;// по мет. Azi := 270; otk = 0;&#xA;//       Bzx :=  (Hzp5 + Hzp6)/(Hxp5 + Hxp6);&#xA;//       Bzy :=  (Hzp5 - Hzp6)/(Hyp6 - Hyp5);&#xA;&#xA; // точкa 20 Azi := 90; otk = 90;&#xA;//       c := Hxp5*Hyp5 + Hxp6*Hyp6;&#xA;//       h := (Hxp6-Hyp5)/c;&#xA; //      c := -(Hyp6+Hxp5)/c;&#xA;       Hxp5 := alg.STEP19.magnit.X.DEV.VALUE;&#xA;       Hyp5 := alg.STEP19.magnit.Y.DEV.VALUE;&#xA;       Hxp6 := alg.STEP20.magnit.X.DEV.VALUE;&#xA;       Hyp6 := alg.STEP20.magnit.Y.DEV.VALUE;&#xA;&#xA;       Bzx := (-Hzp5*Hyp6 + Hzp6*Hyp5)/(Hxp5*Hyp6 - Hxp6*Hyp5);&#xA;       Bzy := (-Hzp6*Hxp5 + Hzp5*Hxp6)/(Hxp5*Hyp6 - Hxp6*Hyp5);&#xA;//       Bzx := -h*Hzp5 - c*Hzp6;&#xA;//       Bzy :=  c*Hzp5 - h*Hzp6;&#xA;&#xA;//       Bzx :=  (Hzp5*(Hyp5 - Hxp6) + Hzp6*(Hyp6 + Hxp5))/(Hxp6*Hyp6 + Hxp5*Hyp5);&#xA;//       Bzy := -(Hzp5*(Hyp6 + Hxp5) - Hzp6*(Hyp5 - Hxp6))/(Hxp6*Hyp6 + Hxp5*Hyp5);&#xA;&#xA;       // переводим поправки по метидикe в стандартные&#xA;       // обновляем буржуйскую таблицу поправок&#xA;       trr.magnit.m3x4.m12 := -Bxy/Khx;&#xA;       trr.magnit.m3x4.m13 :=  Bxz/Khx;&#xA;&#xA;       trr.magnit.m3x4.m21 :=  Byx/Khy;&#xA;       trr.magnit.m3x4.m23 := -Byz/Khy;&#xA;&#xA;       trr.magnit.m3x4.m31 :=  Bzx;///Khz;&#xA;       trr.magnit.m3x4.m32 :=  Bzy;///Khz;&#xA;// ****** test *****&#xA;//       TrrVect3D(trr.magnit.m3x4, alg.STEP9.magnit);&#xA;//       TrrVect3D(trr.magnit.m3x4, alg.STEP10.magnit);&#xA;//       TrrVect3D(trr.magnit.m3x4, alg.STEP11.magnit);&#xA;&#xA;      end;&#xA;  end;&#xA;end;&#xA;&#xA;{&#xA;      альфы акселерометров&#xA;   1    -Axy     Axz&#xA;   0      1     -Ayz      для Gp =  (Gn - S)/K&#xA; -Azx    Azy      1&#xA;&#xA;      бетты магнитометров&#xA;    1   -Bxy     Bxz&#xA;   Byx    1     -Byz      для Hp =  (Hn - S)/K&#xA;  -Bzx   Bzy      1&#xA;&#xA;  матрица буржуев&#xA;  m11    m12     m13     m14&#xA;  m21    m22     m23     m24&#xA;  m31    m32     m33     m34&#xA;&#xA;  mx1-3 = alpha/Kx&#xA;  mx4   = -Sx/Kx&#xA; }&#xA;&#xA;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d: Variant;&#xA;  procedure Addd(const nm: string);&#xA;  begin&#xA;    d := AddXmlPath(s,nm);&#xA;    AddXmlPath(d, 'X.DEV');&#xA;    AddXmlPath(d, 'X.CLC');&#xA;    AddXmlPath(d, 'Y.DEV');&#xA;    AddXmlPath(d, 'Y.CLC');&#xA;    AddXmlPath(d, 'Z.DEV');&#xA;    AddXmlPath(d, 'Z.CLC');&#xA;    d.X.CLC.VALUE := 0;&#xA;    d.Y.CLC.VALUE := 0;&#xA;    d.Z.CLC.VALUE := 0;&#xA;    d.X.DEV.VALUE := 0;&#xA;    d.Y.DEV.VALUE := 0;&#xA;    d.Z.DEV.VALUE := 0;&#xA;  end;&#xA;begin&#xA;  for i := 1 to 20 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i) );&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    Addd('accel');&#xA;    Addd('magnit');&#xA;    AddXmlPath(s, 'TASK');&#xA;   end;&#xA; t.STEP1.INFO := '1) Установить зенитный угол 90 градусов. Изменяя визирный угол установить минимум Gx &lt; 0 (Gy = 0).';&#xA; t.STEP1.TASK.Zenit_Stol := 90;&#xA; t.STEP1.TASK.Vizir_Dev  := 0;&#xA; t.STEP1.TASK.Dalay_Kadr := 5;&#xA; t.STEP2.INFO := '2) Установить зенитный угол 90 градусов. Изменяя визирный угол установить максимум Gx &gt; 0 (Gy = 0).';&#xA; t.STEP2.TASK.Vizir_Dev  := 180;&#xA; t.STEP2.TASK.Dalay_Kadr := 5;&#xA; t.STEP3.INFO := '3) Установить зенитный угол 90 градусов. Изменяя визирный угол установить минимум Gy &lt; 0 (Gx = 0).';&#xA; t.STEP3.TASK.Vizir_Dev  := 90;&#xA; t.STEP3.TASK.Dalay_Kadr := 5;&#xA; t.STEP4.INFO := '4) Установить зенитный угол 90 градусов. Изменяя визирный угол установить максимум Gy &gt; 0 (Gx = 0).';&#xA; t.STEP4.TASK.Vizir_Dev  := 270;&#xA; t.STEP4.TASK.Dalay_Kadr := 5;&#xA; t.STEP5.INFO := '5) Установить зенитный угол 180 градусов.';&#xA; t.STEP5.TASK.Zenit_Stol := 180;&#xA; t.STEP5.TASK.Dalay_Kadr := 5;&#xA; t.STEP6.INFO := '6) Установить зенитный угол 0 градусов.';&#xA; t.STEP6.TASK.Zenit_Stol := 0;&#xA; t.STEP6.TASK.Dalay_Kadr := 5;&#xA; t.STEP7.INFO := '7) Установить зенитный угол 90 градусов. Установить визирный угол 0 градусов при Gy = 0, Gx &lt; 0.';&#xA; t.STEP7.TASK.Zenit_Stol := 90;&#xA; t.STEP7.TASK.Vizir_Dev  := 0;&#xA; t.STEP7.TASK.Dalay_Kadr := 5;&#xA; t.STEP8.INFO := '8) Установить зенитный угол 90 градусов. Установить визирный угол 90 градусов.';&#xA; t.STEP8.TASK.Vizir_Stol  := 90;&#xA; t.STEP8.TASK.Dalay_Kadr := 5;&#xA; t.STEP9.INFO := '9) Установить зенитный угол 90 градусов, азимут — 90 градусов. Изменяя визирный угол установить минимум Hx &lt; 0.';&#xA; t.STEP9.TASK.Azimut_Stol := 90;&#xA; t.STEP9.TASK.Zenit_Stol := 90;&#xA; t.STEP9.TASK.MinHX  := 0;&#xA; t.STEP9.TASK.Dalay_Kadr := 5;&#xA; t.STEP10.INFO := '10) Установить зенитный угол 90 градусов, азимут — 90 градусов. Изменяя визирный угол установить максимум Hx &gt; 0.';&#xA; t.STEP10.TASK.MaxHX  := 0;&#xA; t.STEP10.TASK.Dalay_Kadr := 5;&#xA; t.STEP11.INFO := '11) Установить зенитный угол 90 градусов, азимут — 90 градусов. Изменяя визирный угол установить минимум Hy &lt; 0.';&#xA; t.STEP11.TASK.MinHY  := 0;&#xA; t.STEP11.TASK.Dalay_Kadr := 5;&#xA; t.STEP12.INFO := '12) Установить зенитный угол 90 градусов, азимут — 90 градусов. Изменяя визирный угол установить максимум Hy &gt; 0.';&#xA; t.STEP12.TASK.MaxHY  := 0;&#xA; t.STEP12.TASK.Dalay_Kadr := 5;&#xA; t.STEP13.INFO := '13) Установить азимут 180 градусов. Изменяя зенитный угол в диапазоне от 158 до 162 градусов установить минимум Hz &lt; 0.';&#xA; t.STEP13.TASK.Azimut_Stol := 180;&#xA; t.STEP13.TASK.MinHZ := 0;&#xA; t.STEP13.TASK.Dalay_Kadr := 5;&#xA; t.STEP14.INFO := '14) Установить азимут 0 градусов. Изменяя зенитный угол в диапазоне от 18 до 22 градусов установить максимум Hz &gt; 0.';&#xA; t.STEP14.TASK.Azimut_Stol := 0;&#xA; t.STEP14.TASK.MaxHZ := 0;&#xA; t.STEP14.TASK.Dalay_Kadr := 5;&#xA; t.STEP15.INFO := '15) Установить зенитный угол 90 градусов. Установить азимут 0 градусов. Установить визирный угол 0 градусов.';&#xA; t.STEP15.TASK.Azimut_Stol := 0;&#xA; t.STEP15.TASK.Zenit_Stol := 90;&#xA; t.STEP15.TASK.Vizir_Stol  := 0;&#xA; t.STEP15.TASK.Dalay_Kadr := 5;&#xA; t.STEP16.INFO := '16) Установить зенитный угол 90 градусов. Установить азимут 0 градусов. Установить визирный угол 90 градусов.';&#xA; t.STEP16.TASK.Vizir_Stol  := 90;&#xA; t.STEP16.TASK.Dalay_Kadr := 5;&#xA; t.STEP17.INFO := '17) Установить зенитный угол 90 градусов. Установить азимут 0 градусов. Установить визирный угол 180 градусов.';&#xA; t.STEP17.TASK.Vizir_Stol  := 180;&#xA; t.STEP17.TASK.Dalay_Kadr := 5;&#xA; t.STEP18.INFO := '18) Установить зенитный угол 90 градусов. Установить азимут 0 градусов. Установить визирный угол 270 градусов.';&#xA; t.STEP18.TASK.Vizir_Stol  := 270;&#xA; t.STEP18.TASK.Dalay_Kadr := 5;&#xA; t.STEP19.INFO := '19) Установить зенитный угол 90 градусов. Установить азимут 90 градусов. Установить визирный угол 0 градусов.';&#xA; t.STEP19.TASK.Azimut_Stol := 90;&#xA; t.STEP19.TASK.Vizir_Stol  := 0;&#xA; t.STEP19.TASK.Dalay_Kadr := 5;&#xA; t.STEP20.INFO := '20) Установить зенитный угол 90 градусов. Установить азимут 270 градусов. Установить визирный угол 0 градусов.';&#xA; t.STEP20.TASK.Azimut_Stol := 270;&#xA; t.STEP20.TASK.Dalay_Kadr := 5;&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</T21>
			<T_OLD>
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование в печать диаграмм(*.inc)|*.inc';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ExportToInc( TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
			</T_OLD>
			<P_1>
				<IMPORT IMPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Импортирование из Inc (*.inc)|*.inc';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ImportIncFile(TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
				<EXPORT EXPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ExportP1ToCalc(TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
			</P_1>
			<P_2>
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ExportP2ToCalc(TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" EXPORT1="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование в печать диаграмм(*.inc)|*.inc';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ExportToInc( TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
			</P_2>
			<P_3>
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ExportP3ToCalc(TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" EXPORT1="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование в печать диаграмм(*.inc)|*.inc';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ExportToInc( TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
			</P_3>
			<T_OLD_old EXEC_METR="procedure execute_step(stp: integer; alg, trr: variant);&#xA;begin&#xA;  ExecStepIncl_OLD(stp, alg, trr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d: Variant;&#xA;  procedure Addd(const nm: string);&#xA;  begin&#xA;    d := AddXmlPath(s,nm);&#xA;    AddXmlPath(d, 'X.DEV');&#xA;    AddXmlPath(d, 'X.CLC');&#xA;    AddXmlPath(d, 'Y.DEV');&#xA;    AddXmlPath(d, 'Y.CLC');&#xA;    AddXmlPath(d, 'Z.DEV');&#xA;    AddXmlPath(d, 'Z.CLC');&#xA;    d.X.CLC.VALUE := 0;&#xA;    d.Y.CLC.VALUE := 0;&#xA;    d.Z.CLC.VALUE := 0;&#xA;    d.X.DEV.VALUE := 0;&#xA;    d.Y.DEV.VALUE := 0;&#xA;    d.Z.DEV.VALUE := 0;&#xA;  end;&#xA;begin&#xA;  SetupRoll(1, 90.0, 90.0, t);&#xA;{  for i := 1 to 20 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i) );&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    Addd('accel');&#xA;    Addd('magnit');&#xA;    AddXmlPath(s, 'TASK');&#xA;   end;&#xA; t.STEP1.INFO := '1) Установить зенитный угол 90 градусов. Изменяя визирный угол установить минимум Gx &lt; 0 (Gy = 0).';&#xA; t.STEP1.TASK.Zenit_Stol := 90;&#xA; t.STEP1.TASK.Vizir_Dev  := 0;&#xA; t.STEP1.TASK.Dalay_Kadr := 5;&#xA; t.STEP2.INFO := '2) Установить зенитный угол 90 градусов. Изменяя визирный угол установить максимум Gx &gt; 0 (Gy = 0).';&#xA; t.STEP2.TASK.Vizir_Dev  := 180;&#xA; t.STEP2.TASK.Dalay_Kadr := 5;&#xA; t.STEP3.INFO := '3) Установить зенитный угол 90 градусов. Изменяя визирный угол установить минимум Gy &lt; 0 (Gx = 0).';&#xA; t.STEP3.TASK.Vizir_Dev  := 90;&#xA; t.STEP3.TASK.Dalay_Kadr := 5;&#xA; t.STEP4.INFO := '4) Установить зенитный угол 90 градусов. Изменяя визирный угол установить максимум Gy &gt; 0 (Gx = 0).';&#xA; t.STEP4.TASK.Vizir_Dev  := 270;&#xA; t.STEP4.TASK.Dalay_Kadr := 5;&#xA; t.STEP5.INFO := '5) Установить зенитный угол 180 градусов.';&#xA; t.STEP5.TASK.Zenit_Stol := 180;&#xA; t.STEP5.TASK.Dalay_Kadr := 5;&#xA; t.STEP6.INFO := '6) Установить зенитный угол 0 градусов.';&#xA; t.STEP6.TASK.Zenit_Stol := 0;&#xA; t.STEP6.TASK.Dalay_Kadr := 5;&#xA; t.STEP7.INFO := '7) Установить зенитный угол 90 градусов. Установить визирный угол 0 градусов при Gy = 0, Gx &lt; 0.';&#xA; t.STEP7.TASK.Zenit_Stol := 90;&#xA; t.STEP7.TASK.Vizir_Dev  := 0;&#xA; t.STEP7.TASK.Dalay_Kadr := 5;&#xA; t.STEP8.INFO := '8) Установить зенитный угол 90 градусов. Установить визирный угол 90 градусов.';&#xA; t.STEP8.TASK.Vizir_Stol  := 90;&#xA; t.STEP8.TASK.Dalay_Kadr := 5;&#xA; t.STEP9.INFO := '9) Установить зенитный угол 90 градусов, азимут — 90 градусов. Изменяя визирный угол установить минимум Hx &lt; 0.';&#xA; t.STEP9.TASK.Azimut_Stol := 90;&#xA; t.STEP9.TASK.Zenit_Stol := 90;&#xA; t.STEP9.TASK.MinHX  := 0;&#xA; t.STEP9.TASK.Dalay_Kadr := 5;&#xA; t.STEP10.INFO := '10) Установить зенитный угол 90 градусов, азимут — 90 градусов. Изменяя визирный угол установить максимум Hx &gt; 0.';&#xA; t.STEP10.TASK.MaxHX  := 0;&#xA; t.STEP10.TASK.Dalay_Kadr := 5;&#xA; t.STEP11.INFO := '11) Установить зенитный угол 90 градусов, азимут — 90 градусов. Изменяя визирный угол установить минимум Hy &lt; 0.';&#xA; t.STEP11.TASK.MinHY  := 0;&#xA; t.STEP11.TASK.Dalay_Kadr := 5;&#xA; t.STEP12.INFO := '12) Установить зенитный угол 90 градусов, азимут — 90 градусов. Изменяя визирный угол установить максимум Hy &gt; 0.';&#xA; t.STEP12.TASK.MaxHY  := 0;&#xA; t.STEP12.TASK.Dalay_Kadr := 5;&#xA; t.STEP13.INFO := '13) Установить азимут 180 градусов. Изменяя зенитный угол в диапазоне от 158 до 162 градусов установить минимум Hz &lt; 0.';&#xA; t.STEP13.TASK.Azimut_Stol := 180;&#xA; t.STEP13.TASK.MinHZ := 0;&#xA; t.STEP13.TASK.Dalay_Kadr := 5;&#xA; t.STEP14.INFO := '14) Установить азимут 0 градусов. Изменяя зенитный угол в диапазоне от 18 до 22 градусов установить максимум Hz &gt; 0.';&#xA; t.STEP14.TASK.Azimut_Stol := 0;&#xA; t.STEP14.TASK.MaxHZ := 0;&#xA; t.STEP14.TASK.Dalay_Kadr := 5;&#xA; t.STEP15.INFO := '15) Установить зенитный угол 90 градусов. Установить азимут 0 градусов. Установить визирный угол 0 градусов.';&#xA; t.STEP15.TASK.Azimut_Stol := 0;&#xA; t.STEP15.TASK.Zenit_Stol := 90;&#xA; t.STEP15.TASK.Vizir_Stol  := 0;&#xA; t.STEP15.TASK.Dalay_Kadr := 5;&#xA; t.STEP16.INFO := '16) Установить зенитный угол 90 градусов. Установить азимут 0 градусов. Установить визирный угол 90 градусов.';&#xA; t.STEP16.TASK.Vizir_Stol  := 90;&#xA; t.STEP16.TASK.Dalay_Kadr := 5;&#xA; t.STEP17.INFO := '17) Установить зенитный угол 90 градусов. Установить азимут 0 градусов. Установить визирный угол 180 градусов.';&#xA; t.STEP17.TASK.Vizir_Stol  := 180;&#xA; t.STEP17.TASK.Dalay_Kadr := 5;&#xA; t.STEP18.INFO := '18) Установить зенитный угол 90 градусов. Установить азимут 0 градусов. Установить визирный угол 270 градусов.';&#xA; t.STEP18.TASK.Vizir_Stol  := 270;&#xA; t.STEP18.TASK.Dalay_Kadr := 5;&#xA; t.STEP19.INFO := '19) Установить зенитный угол 90 градусов. Установить азимут 90 градусов. Установить визирный угол 0 градусов.';&#xA; t.STEP19.TASK.Azimut_Stol := 90;&#xA; t.STEP19.TASK.Vizir_Stol  := 0;&#xA; t.STEP19.TASK.Dalay_Kadr := 5;&#xA; t.STEP20.INFO := '20) Установить зенитный угол 90 градусов. Установить азимут 270 градусов. Установить визирный угол 0 градусов.';&#xA; t.STEP20.TASK.Azimut_Stol := 270;&#xA; t.STEP20.TASK.Dalay_Kadr := 5;      }&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</T_OLD_old>
		</MODEL>
	</Inclin>
	<accel SETUP_METR="begin&#xA;//  тип создание ветви поправкок и заполнение значениями по умолчанию&#xA;// косоугольность, смещение 0 амплит. акселер.&#xA;//  AddXmlPath(t, 'accel');&#xA;//  AddXmlMatrix(t.accel, 3,4);&#xA;// по умолранию амплит=1 остальнвые 0&#xA;//  t.accel.m3x4.m11 := 1;&#xA;//  t.accel.m3x4.m22 := 1;&#xA;//  t.accel.m3x4.m33 := 1;&#xA;// косоугольность, смещение 0 амплит. магнит.&#xA;//  AddXmlPath(t, 'magnit');&#xA;//  AddXmlMatrix(t.magnit, 3,4);&#xA;// по умолранию амплит=1 остальнвые 0&#xA;//  t.magnit.m3x4.m11 := 1;&#xA;//  t.magnit.m3x4.m22 := 1;&#xA;//  t.magnit.m3x4.m33 := 1;&#xA;end;&#xA;&#xA;"><IMPORT/>
		<EXPORT/>
		<MODEL>
			<CLA1 EXEC_METR="{ procedure ( v, t: variant);&#xA;  t - корневой элемент метрологии&#xA;  где v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA; var&#xA;  os,oc,zs,zc,&#xA;  a, zu, o, mo, b,&#xA;  x,y,z, Hx, Hy, Hz: Double;&#xA;  res: Variant;&#xA;begin&#xA;// получение тарированных данных&#xA;// m3x4- содержит информацию о размерности атрибуты - данные ряды, строки&#xA;// TrrVect3D - спецализированная функ = V3D.TRR := M3x4 * V4D.ROW*Scale&#xA;// - четвертая размерность V[4].ROW=1&#xA;// ROW- атрибут сырые данные с прибора&#xA;//  TrrVect3D(t.accel.m3x4, v.accel);//, 1000);&#xA;  v.X.CLC.VALUE := v.X.DEV.VALUE*2000/$8000;&#xA;  v.Y.CLC.VALUE := v.Y.DEV.VALUE*2000/$8000;&#xA;  v.Z.CLC.VALUE := v.Z.DEV.VALUE*2000/$8000;&#xA;&#xA;  x := v.X.CLC.VALUE;&#xA;  y := v.Y.CLC.VALUE;&#xA;  z := v.Z.CLC.VALUE;&#xA;&#xA;  v.амплит_accel.CLC.VALUE := Hypot3D(x, y, z);&#xA;&#xA;  o := Arctan2(y, -x);&#xA;  zu := Arctan2(Hypot(x, y), z);&#xA;&#xA;  v.зенит.CLC.VALUE       := RadToDeg_0_180(zu);&#xA;  v.отклонитель.CLC.VALUE := RadToDeg_0_360(o);&#xA;end;&#xA;" SETUP_METR=" var&#xA;  m: variant;&#xA;begin&#xA;// Форматирование и вычисляемые параметры&#xA;//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m := AddMetrology(v.X, 'AX', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, $FFFF0000, 3, 1);&#xA;&#xA;  m := AddMetrology(v.Y, 'AY', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, $FF00FF00, 3, 1);&#xA;&#xA;  m := AddMetrology(v.Z, 'AZ', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, -2000, 2000);&#xA;  AddMetrologyCL(m, $FF0000FF, 3, 1);&#xA;&#xA;  m := AddMetrology(v.X.DEV, 'ax', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -$8000, $8000);&#xA;  AddMetrologyCL(m, $808F0000, 1, 1);&#xA;  m := AddMetrology(v.Y.DEV, 'ay', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -$8000, $8000);&#xA;  AddMetrologyCL(m, $80008F00, 1, 1);&#xA;  m := AddMetrology(v.Z.DEV, 'az', '');&#xA;  AddMetrologyFM(m, 8, 0);&#xA;  AddMetrologyRG(m, -$8000, $8000);&#xA;  AddMetrologyCL(m, $8000008F, 1, 1);&#xA;&#xA;  // вычисляемые параметры&#xA;  AddXmlPath(v, 'зенит');&#xA;  v.зенит.METR := 'ANGLE';&#xA;  m := AddMetrology(v.зенит, 'зенит', 'º');&#xA;  AddMetrologyFM(m, 8, 2);&#xA;  AddMetrologyRG(m, 0, 180);&#xA;  AddMetrologyCL(m, $C0800080, 2, 2);&#xA;&#xA;  AddXmlPath(v, 'отклонитель');&#xA;  v.отклонитель.METR := 'ANGLE';&#xA;  m := AddMetrology(v.отклонитель, 'визир', 'º');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 360);&#xA;  AddMetrologyCL(m, $C0404000, 2, 1);&#xA;&#xA;  AddXmlPath(v, 'амплит_accel');&#xA;  m := AddMetrology(v.амплит_accel, 'A', 'G');&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 1000);&#xA;  AddMetrologyCL(m, $C0408000, 2, 2);&#xA;&#xA;end;&#xA;&#xA;"><IMPORT/>
				<EXPORT/>
			</CLA1></MODEL>
	</accel><ГК SETUP_METR="begin&#xA;  t.kGK := 1;&#xA;end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<GK1 EXEC_METR="{ procedure ( v, t: variant);&#xA;  t - корневой элемент метрологии&#xA;  где v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;//  SGK_FindGK(v);&#xA;  v.гк.CLC.VALUE :=  t.kGK * v.гк.DEV.VALUE;&#xA;end;&#xA;" SETUP_METR=" var&#xA;  m: variant;&#xA;begin&#xA;// Форматирование и вычисляемые параметры&#xA;//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m := AddMetrology(v.гк, 'гк', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, $FFFF0000);&#xA;&#xA;//  AddMetrology(v.гк, 'мкР/ч', '%8.1f',  0, 200);&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</GK1>
			<GK_SGK EXEC_METR="{ procedure ( v, t: variant);&#xA;  t - корневой элемент метрологии&#xA;  где v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  SGK_FindGK(v);&#xA;  v.гк.CLC.VALUE :=  t.kGK * v.гк.DEV.VALUE;&#xA;end;&#xA;" SETUP_METR=" var&#xA;  m: variant;&#xA;begin&#xA;// Форматирование и вычисляемые параметры&#xA;//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m := AddMetrology(v.гк, 'гк', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, $FFFF0000);&#xA;&#xA;//  AddMetrology(v.гк, 'мкР/ч', '%8.1f',  0, 200);&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</GK_SGK>
			<TGK EXEC_METR="procedure execute_step(stp: integer; alg, trr: variant);&#xA; var&#xA;  st: variant;&#xA;  a, Dz: Double;&#xA;begin&#xA;  if alg.STEP7.гк.DEV.VALUE &lt;&gt; alg.STEP3.гк.DEV.VALUE then&#xA;       trr.kGK := 40/(alg.STEP7.гк.DEV.VALUE - alg.STEP3.гк.DEV.VALUE);&#xA;&#xA;  a := trr.kGK;&#xA;&#xA;  Dz := alg.STEP1.гк.DEV.VALUE * a;&#xA;&#xA;  trr.Delta := alg.STEP1.гк.DEV.VALUE;&#xA;&#xA;  if stp = 1 then alg.STEP1.гк.CLC.VALUE := Dz&#xA;  else&#xA;   begin&#xA;    st := AddXmlPath(alg, 'STEP' + IntToStr(stp));&#xA;    st.гк.CLC.VALUE := st.гк.DEV.VALUE * a - Dz;&#xA;    st.DELTA := (st.гк.CLC.VALUE - st.RT)*100/st.RT;&#xA;   end;&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d, e: Variant;&#xA;begin&#xA;  for i := 1 to 10 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i) );&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    s.DELTA := 0;&#xA;    d := AddXmlPath(s,'гк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;    e := AddXmlPath(s,'TASK');&#xA;   end;&#xA;&#xA; t.STEP1.ATT_COUNT := 50;&#xA; t.STEP2.ATT_COUNT := 50;&#xA; t.STEP3.ATT_COUNT := 50;&#xA; t.STEP4.ATT_COUNT := 50;&#xA; t.STEP5.ATT_COUNT := 50;&#xA; t.STEP6.ATT_COUNT := 50;&#xA; t.STEP7.ATT_COUNT := 50;&#xA; t.STEP8.ATT_COUNT := 50;&#xA; t.STEP9.ATT_COUNT := 50;&#xA; t.STEP10.ATT_COUNT := 50;&#xA;&#xA;&#xA; t.STEP1.TASK.Gk_Stol := 'P0_HOME';&#xA; t.STEP2.TASK.Gk_Stol := 'P5_HOME';&#xA; t.STEP3.TASK.Gk_Stol := 'P10S';&#xA; t.STEP4.TASK.Gk_Stol := 'P20';&#xA; t.STEP5.TASK.Gk_Stol := 'P30S';&#xA; t.STEP6.TASK.Gk_Stol := 'P40';&#xA; t.STEP7.TASK.Gk_Stol := 'P50S';&#xA; t.STEP8.TASK.Gk_Stol := 'P100';&#xA; t.STEP9.TASK.Gk_Stol := 'P150';&#xA; t.STEP10.TASK.Gk_Stol := 'P200';&#xA;&#xA; t.STEP1.RT := 0;&#xA; t.STEP2.RT := 5;&#xA; t.STEP3.RT := 10;&#xA; t.STEP4.RT := 20;&#xA; t.STEP5.RT := 30;&#xA; t.STEP6.RT := 40;&#xA; t.STEP7.RT := 50;&#xA; t.STEP8.RT := 100;&#xA; t.STEP9.RT := 150;&#xA; t.STEP10.RT := 200;&#xA;&#xA; t.STEP1.INFO := '1) фон 0.';&#xA; t.STEP2.INFO := '2) - 5';&#xA; t.STEP3.INFO := '3) 3.095 10';&#xA; t.STEP4.INFO := '4) 2.188 20';&#xA; t.STEP5.INFO := '5) 1.787 30';&#xA; t.STEP6.INFO := '6) 1.547 40';&#xA; t.STEP7.INFO := '7) 1.384 50';&#xA; t.STEP8.INFO := '8) 0.979 100';&#xA; t.STEP9.INFO := '9) 0.799 150';&#xA; t.STEP10.INFO := '10) 0.692 200';&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ExportGKToCalc(TrrFile, NewTrr, 'GK');&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
			</TGK>
			<TGK_LS EXEC_METR="procedure execute_step(stp: integer; alg, trr: variant);&#xA;begin&#xA;  ExecStepGK1(stp, alg, trr, True);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d: Variant;&#xA;begin&#xA;  for i := 1 to 10 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i) );&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    s.DELTA := 0;&#xA;    d := AddXmlPath(s,'гк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;   end;&#xA;&#xA; t.STEP1.DISTANCE := 'фон';&#xA; t.STEP2.DISTANCE := '-';&#xA; t.STEP3.DISTANCE := '3.095';&#xA; t.STEP4.DISTANCE := '2.188';&#xA; t.STEP5.DISTANCE := '1.787';&#xA; t.STEP6.DISTANCE := '1.547';&#xA; t.STEP7.DISTANCE := '1.384';&#xA; t.STEP8.DISTANCE := '0.979';&#xA; t.STEP9.DISTANCE := '0.799';&#xA; t.STEP10.DISTANCE := '0.692';&#xA;&#xA; t.STEP1.RT := 0;&#xA; t.STEP2.RT := 5;&#xA; t.STEP3.RT := 10;&#xA; t.STEP4.RT := 20;&#xA; t.STEP5.RT := 30;&#xA; t.STEP6.RT := 40;&#xA; t.STEP7.RT := 50;&#xA; t.STEP8.RT := 100;&#xA; t.STEP9.RT := 150;&#xA; t.STEP10.RT := 200;&#xA;&#xA; t.STEP1.INFO := '1) фон 0.';&#xA; t.STEP2.INFO := '2) - 5';&#xA; t.STEP3.INFO := '3) 3.095 10';&#xA; t.STEP4.INFO := '4) 2.188 20';&#xA; t.STEP5.INFO := '5) 1.787 30';&#xA; t.STEP6.INFO := '6) 1.547 40';&#xA; t.STEP7.INFO := '7) 1.384 50';&#xA; t.STEP8.INFO := '8) 0.979 100';&#xA; t.STEP9.INFO := '9) 0.799 150';&#xA; t.STEP10.INFO := '10) 0.692 200';&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ExportGKToCalc(TrrFile, NewTrr, 'GK');&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
			</TGK_LS>
		</MODEL>
	</ГК>
	<Глубиномер SETUP_METR="begin&#xA; // t.kGK := 1;&#xA;end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<RP45 EXEC_METR="{ procedure ( v, t: variant);&#xA;  t - корневой элемент метрологии&#xA;  где v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;begin&#xA;  v.ДлинаТроса.CLC.VALUE := 0.018686833 * v.ДлинаТроса.DEV.VALUE;&#xA;end;&#xA;" SETUP_METR=" var&#xA;  m: Variant;&#xA;begin&#xA;  m := AddMetrology(v.ДлинаТроса, 'Трос', 'см.');&#xA;  AddMetrologyFM(m, 4, 2);&#xA;  AddMetrologyRG(m, 0, 4500);&#xA;  AddMetrologyCL(m, $FF008080, 3, 1);&#xA;  // вычисляемые параметры&#xA;  AddXmlPath(v, 'Глубина');&#xA;  m := AddMetrology(v.Глубина, 'Глубина', 'м.');&#xA;  AddMetrologyFM(m, 4, 2);&#xA;  AddMetrologyCL(m, $FF8080F0, 2, 1);&#xA;  m := AddMetrology(v.Нагрузка.DEV, 'Нагрузка', 'уе.');&#xA;  AddMetrologyFM(m, 4, 0);&#xA;  AddMetrologyCL(m, $D0405050, 2, 2);&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</RP45>
		</MODEL>
	</Глубиномер>
	<ННК SETUP_METR="begin&#xA;&#xA;  t.kNGK := 1;&#xA;  t.KW1 := 700;&#xA;  t.KW2 := 70;&#xA;  t.KWG := 100;&#xA;&#xA;  AddXmlPath(t, 'Rbf.A');&#xA;  AddXmlPath(t, 'Rbf.K1');&#xA;  AddXmlPath(t, 'Rbf.K2');&#xA;  AddXmlPath(t, 'Rbf.G');&#xA;  t.Rbf.A.XY := '';&#xA;  t.Rbf.K1.XY := '';&#xA;  t.Rbf.K2.XY := '';&#xA;  t.Rbf.G.XY := '';&#xA;end;&#xA;&#xA;">
		<IMPORT/>
		<EXPORT/>
		<MODEL>
			<NNK1 EXEC_METR="{ procedure ( v, t: variant);&#xA;  t - корневой элемент метрологии&#xA;  где v - корневой элемент редактируемого модуля&#xA;  например Inclin, Dtr - корневой элемент редактируемого модуля }&#xA;  var&#xA;   p: variant;&#xA;   dv, k1, k2, kg, dia: double;&#xA;begin&#xA;  v.нгк.CLC.VALUE := t.kNGK * v.нгк.DEV.VALUE;&#xA;&#xA;  dia := 216/200;// GetProjectData('Диаметр'); // как вариант не создавать в &quot;Установках&quot; а создать директорию? файл? проект&#xA;&#xA;  if t.Rbf.A.XY = ''  then Exit;&#xA;  //if not XmlPathExists(t, 'RUN') then Exit;&#xA;&#xA;  if v.нк1.DEV.VALUE = 0 then k1 := t.KW1 else k1 := t.KW1 / v.нк1.DEV.VALUE;&#xA;  if v.нк2.DEV.VALUE = 0 then k2 := t.KW2 else k2 := t.KW2 / v.нк2.DEV.VALUE;&#xA;  if k1 = 0 then dv := k2 else dv := k2/k1;&#xA;  if FindXmlRoot(v, 'WRK','ГК', p) and (v.нгк.CLC.VALUE &gt; p.гк.CLC.VALUE) then&#xA;     kg := t.KWG / (v.нгк.CLC.VALUE - p.гк.CLC.VALUE) * t.kNGK&#xA;  else&#xA;   if v.нгк.CLC.VALUE = 0 then&#xA;     kg := t.KWG&#xA;   else&#xA;     kg := t.KWG/v.нгк.CLC.VALUE * t.kNGK;&#xA;&#xA;  v.Кп.CLC.VALUE := RbfInterp(t.Rbf.A, dia, dv);&#xA;  v.Кпг.CLC.VALUE := RbfInterp(t.Rbf.G, dia, kg);&#xA;  v.Кпм.CLC.VALUE := RbfInterp(t.Rbf.K1, dia, k1);&#xA;  v.Кпб.CLC.VALUE := RbfInterp(t.Rbf.K2, dia, k2);&#xA;end;&#xA;" SETUP_METR=" var&#xA;  m: variant;&#xA;begin&#xA;  AddXmlPath(v, 'Кп');&#xA;  AddXmlPath(v, 'Кпм');&#xA;  AddXmlPath(v, 'Кпб');&#xA;  AddXmlPath(v, 'Кпг');&#xA;  // переменная вводится вручную или саздать в проекте?&#xA;  AddXmlPath(v, 'Диаметр');&#xA;&#xA;// Форматирование и вычисляемые параметры&#xA;//  AddMetrology(v.accel.T, '°C', '%8.1f',  -40, 150, 1.1);&#xA;  m := AddMetrology(v.нгк, 'нгк', 'мкР/ч', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 200);&#xA;  AddMetrologyCL(m, $FFFF0000);&#xA;&#xA;  m := AddMetrology(v.Кп, 'Кп', '%', 1.1);&#xA;  AddMetrologyFM(m, 1, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, $FFFF0000);&#xA;&#xA;  m := AddMetrology(v.Кпм, 'Кпм', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, $FFFF0000);&#xA;&#xA;  m := AddMetrology(v.Кпм, 'Кпм', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, $FFFF0000);&#xA;&#xA;  m := AddMetrology(v.Кпб, 'Кпб', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, $FFFF0000);&#xA;&#xA;  m := AddMetrology(v.Кпг, 'Кпг', '%', 1.1);&#xA;  AddMetrologyFM(m, 8, 1);&#xA;  AddMetrologyRG(m, 0, 100);&#xA;  AddMetrologyCL(m, $FFFF0000);&#xA;&#xA;  m := AddMetrology(v.Диаметр, 'Диаметр', 'мм', 1.1);&#xA;  AddMetrologyFM(m, 8, 0);&#xA;&#xA;  v.Диаметр.CLC.VALUE := 216;&#xA;&#xA;//  AddXmlPath(v, 'Диаметр');&#xA;//  AddMetrology(v.Диаметр, 'мм.', '%1.0f', 0, 400);&#xA;//  v.Диаметр.CLC.VALUE := 216;&#xA;//  DivArray(t.нк1,  t.нк2,  t.нк);&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</NNK1>
			<TNGK EXEC_METR="procedure execute_step(stp: integer; alg, trr: variant);&#xA; var&#xA;  st: variant;&#xA;  a, Dz: Double;&#xA;begin&#xA;  if alg.STEP7.нгк.DEV.VALUE &lt;&gt; alg.STEP3.нгк.DEV.VALUE then&#xA;       trr.kNGK := 40/(alg.STEP7.нгк.DEV.VALUE - alg.STEP3.нгк.DEV.VALUE);&#xA;&#xA;  a := trr.kNGK;&#xA;&#xA;  Dz := alg.STEP1.нгк.DEV.VALUE * a;&#xA;&#xA;  trr.Delta := alg.STEP1.нгк.DEV.VALUE;&#xA;&#xA;  if stp = 1 then alg.STEP1.нгк.CLC.VALUE := Dz&#xA;  else&#xA;   begin&#xA;    st := AddXmlPath(alg, 'STEP' + IntToStr(stp));&#xA;    st.нгк.CLC.VALUE := st.нгк.DEV.VALUE * a - Dz;&#xA;    st.DELTA := (st.нгк.CLC.VALUE - st.RT)*100/st.RT;&#xA;   end;&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d, e: Variant;&#xA;begin&#xA;  for i := 1 to 10 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i) );&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    s.DELTA := 0;&#xA;    d := AddXmlPath(s,'нгк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;    e := AddXmlPath(s,'TASK');&#xA;   end;&#xA;&#xA; t.STEP1.ATT_COUNT := 50;&#xA; t.STEP2.ATT_COUNT := 50;&#xA; t.STEP3.ATT_COUNT := 50;&#xA; t.STEP4.ATT_COUNT := 50;&#xA; t.STEP5.ATT_COUNT := 50;&#xA; t.STEP6.ATT_COUNT := 50;&#xA; t.STEP7.ATT_COUNT := 50;&#xA; t.STEP8.ATT_COUNT := 50;&#xA; t.STEP9.ATT_COUNT := 50;&#xA; t.STEP10.ATT_COUNT := 50;&#xA;&#xA;&#xA; t.STEP1.TASK.Gk_Stol := 'P0_HOME';&#xA; t.STEP2.TASK.Gk_Stol := 'P5_HOME';&#xA; t.STEP3.TASK.Gk_Stol := 'P10S';&#xA; t.STEP4.TASK.Gk_Stol := 'P20';&#xA; t.STEP5.TASK.Gk_Stol := 'P30S';&#xA; t.STEP6.TASK.Gk_Stol := 'P40';&#xA; t.STEP7.TASK.Gk_Stol := 'P50S';&#xA; t.STEP8.TASK.Gk_Stol := 'P100';&#xA; t.STEP9.TASK.Gk_Stol := 'P150';&#xA; t.STEP10.TASK.Gk_Stol := 'P200';&#xA;&#xA; t.STEP1.RT := 0;&#xA; t.STEP2.RT := 5;&#xA; t.STEP3.RT := 10;&#xA; t.STEP4.RT := 20;&#xA; t.STEP5.RT := 30;&#xA; t.STEP6.RT := 40;&#xA; t.STEP7.RT := 50;&#xA; t.STEP8.RT := 100;&#xA; t.STEP9.RT := 150;&#xA; t.STEP10.RT := 200;&#xA;&#xA; t.STEP1.INFO := '1) фон 0.';&#xA; t.STEP2.INFO := '2) - 5';&#xA; t.STEP3.INFO := '3) 3.095 10';&#xA; t.STEP4.INFO := '4) 2.188 20';&#xA; t.STEP5.INFO := '5) 1.787 30';&#xA; t.STEP6.INFO := '6) 1.547 40';&#xA; t.STEP7.INFO := '7) 1.384 50';&#xA; t.STEP8.INFO := '8) 0.979 100';&#xA; t.STEP9.INFO := '9) 0.799 150';&#xA; t.STEP10.INFO := '10) 0.692 200';&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ExportGKToCalc(TrrFile, NewTrr, 'NGK');&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
			</TNGK>
			<TNGK_LS EXEC_METR="procedure execute_step(stp: integer; alg, trr: variant);&#xA;begin&#xA;  ExecStepGK1(stp, alg, trr, False);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d: Variant;&#xA;begin&#xA;  for i := 1 to 10 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i) );&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    s.DELTA := 0;&#xA;    d := AddXmlPath(s,'нгк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;   end;&#xA;&#xA; t.STEP1.DISTANCE := 'фон';&#xA; t.STEP2.DISTANCE := '-';&#xA; t.STEP3.DISTANCE := '3.095';&#xA; t.STEP4.DISTANCE := '2.188';&#xA; t.STEP5.DISTANCE := '1.787';&#xA; t.STEP6.DISTANCE := '1.547';&#xA; t.STEP7.DISTANCE := '1.384';&#xA; t.STEP8.DISTANCE := '0.979';&#xA; t.STEP9.DISTANCE := '0.799';&#xA; t.STEP10.DISTANCE := '0.692';&#xA;&#xA; t.STEP1.RT := 0;&#xA; t.STEP2.RT := 5;&#xA; t.STEP3.RT := 10;&#xA; t.STEP4.RT := 20;&#xA; t.STEP5.RT := 30;&#xA; t.STEP6.RT := 40;&#xA; t.STEP7.RT := 50;&#xA; t.STEP8.RT := 100;&#xA; t.STEP9.RT := 150;&#xA; t.STEP10.RT := 200;&#xA;&#xA; t.STEP1.INFO := '1) фон 0.';&#xA; t.STEP2.INFO := '2) - 5';&#xA; t.STEP3.INFO := '3) 3.095 10';&#xA; t.STEP4.INFO := '4) 2.188 20';&#xA; t.STEP5.INFO := '5) 1.787 30';&#xA; t.STEP6.INFO := '6) 1.547 40';&#xA; t.STEP7.INFO := '7) 1.384 50';&#xA; t.STEP8.INFO := '8) 0.979 100';&#xA; t.STEP9.INFO := '9) 0.799 150';&#xA; t.STEP10.INFO := '10) 0.692 200';&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT EXPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование в OpenOffice Calc(*.ods)|*.ods';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ExportGKToCalc(TrrFile, NewTrr, 'NGK');&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
			</TNGK_LS>
			<TNGK_old EXEC_METR="procedure execute_step(stp: integer; alg, trr: variant);&#xA; var&#xA;  st: variant;&#xA;  a, Dz: Double;&#xA;begin&#xA;  if alg.STEP7.нгк.ROW &lt;&gt; alg.STEP3.нгк.ROW then&#xA;       trr.kNGK := 40/(alg.STEP7.нгк.ROW - alg.STEP3.нгк.ROW);&#xA;&#xA;  a := trr.kNGK;&#xA;&#xA;  Dz := alg.STEP1.нгк.ROW * a;&#xA;&#xA;  if stp = 1 then alg.STEP1.нгк.TRR := Dz&#xA;  else&#xA;   begin&#xA;    st := AddXmlPath(alg, 'STEP' + IntToStr(stp));&#xA;    st.нгк.TRR := st.нгк.ROW * a - Dz;&#xA;    st.DELTA := (st.нгк.TRR - st.RT)*100/st.RT;&#xA;   end;&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d: Variant;&#xA;begin&#xA;  for i := 1 to 10 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i) );&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    s.DELTA := 0;&#xA;    d := AddXmlPath(s,'нгк');&#xA;    d.TRR := 0;&#xA;    d.ROW := 0;&#xA;   end;&#xA;&#xA; t.STEP1.DISTANCE := 'фон';&#xA; t.STEP2.DISTANCE := '-';&#xA; t.STEP3.DISTANCE := '3.095';&#xA; t.STEP4.DISTANCE := '2.188';&#xA; t.STEP5.DISTANCE := '1.787';&#xA; t.STEP6.DISTANCE := '1.547';&#xA; t.STEP7.DISTANCE := '1.384';&#xA; t.STEP8.DISTANCE := '0.979';&#xA; t.STEP9.DISTANCE := '0.799';&#xA; t.STEP10.DISTANCE := '0.692';&#xA;&#xA; t.STEP1.RT := 0;&#xA; t.STEP2.RT := 5;&#xA; t.STEP3.RT := 10;&#xA; t.STEP4.RT := 20;&#xA; t.STEP5.RT := 30;&#xA; t.STEP6.RT := 40;&#xA; t.STEP7.RT := 50;&#xA; t.STEP8.RT := 100;&#xA; t.STEP9.RT := 150;&#xA; t.STEP10.RT := 200;&#xA;&#xA; t.STEP1.INFO := '1) фон 0.';&#xA; t.STEP2.INFO := '2) - 5';&#xA; t.STEP3.INFO := '3) 3.095 10';&#xA; t.STEP4.INFO := '4) 2.188 20';&#xA; t.STEP5.INFO := '5) 1.787 30';&#xA; t.STEP6.INFO := '6) 1.547 40';&#xA; t.STEP7.INFO := '7) 1.384 50';&#xA; t.STEP8.INFO := '8) 0.979 100';&#xA; t.STEP9.INFO := '9) 0.799 150';&#xA; t.STEP10.INFO := '10) 0.692 200';&#xA;end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</TNGK_old>
			<TNNK EXEC_METR="&#xA;var&#xA;  k, k1, k2, kg: Double;&#xA;&#xA;procedure execute_step(stp: integer; alg, trr: variant);&#xA;&#xA; var&#xA;  st: variant;&#xA;  i: Integer;&#xA;  dia, xy, xy1, xy2, xyg: string;&#xA;&#xA;  procedure FindPoint;&#xA;  begin&#xA;    if st.нк2.DEV.VALUE = 0 then st.nkw := k * st.нк1.DEV.VALUE else st.nkw := k * st.нк1.DEV.VALUE/st.нк2.DEV.VALUE;&#xA;    if st.нк1.DEV.VALUE = 0 then st.nkw1 := k1 else st.nkw1 := k1/st.нк1.DEV.VALUE;&#xA;    if st.нк2.DEV.VALUE = 0 then st.nkw2 := k2 else st.nkw2 := k2/st.нк2.DEV.VALUE;&#xA;    if st.нгк.DEV.VALUE = 0 then st.nkwg := kg else st.nkwg := kg/st.нгк.DEV.VALUE;&#xA;  end;&#xA;&#xA;begin&#xA;  st := AddXmlPath(alg, 'STEP' + IntToStr(stp));&#xA;&#xA;  case stp of&#xA;   1: begin&#xA;        k1 := st.нк1.DEV.VALUE;&#xA;        k2 := st.нк2.DEV.VALUE;&#xA;        kg := st.нгк.DEV.VALUE;&#xA;        if k1 = 0 then k := k2 else k := k2/k1;&#xA;        FindPoint;&#xA;       end;&#xA;&#xA;   14: begin&#xA;        // обязательно *1 иначе считает что вариант - строка&#xA;        k1 := (alg.STEP1.нк1.DEV.VALUE*1 + alg.STEP11.нк1.DEV.VALUE*1)/2;&#xA;        k2 := (alg.STEP1.нк2.DEV.VALUE*1 + alg.STEP11.нк2.DEV.VALUE*1)/2;&#xA;        kg := (alg.STEP1.нгк.DEV.VALUE*1 + alg.STEP11.нгк.DEV.VALUE*1)/2;&#xA;        if k1 = 0 then k := k2 else k := k2/k1;&#xA;        // коэфф полученн при тарировке&#xA;        trr.KW1 := k1;&#xA;        trr.KW2 := k2;&#xA;        //trr.KW := k; лишнее&#xA;        trr.KWG := kg;&#xA;        xy := '[';  xy1 := '['; xy2 := '['; xyg := '[';&#xA;        for i := 1 to 14 do&#xA;         begin&#xA;          st := AddXmlPath(alg, 'STEP' + IntToStr(i));&#xA;          FindPoint;&#xA;          if i in [1,11] then Continue;&#xA;          dia := FloatToStr(st.D/200);&#xA;          xy  := xy  + '[' + dia + ',' +st.nkw  + ',' + st.KP + ']';&#xA;          xy1 := xy1 + '[' + dia + ',' +st.nkw1 + ',' + st.KP + ']';&#xA;          xy2 := xy2 + '[' + dia + ',' +st.nkw2 + ',' + st.KP + ']';&#xA;          xyg := xyg + '[' + dia + ',' +st.nkwg + ',' + st.KP + ']';&#xA;          if i = 14 then xy  := xy  + ']' else xy  := xy  + ',';&#xA;          if i = 14 then xy1 := xy1 + ']' else xy1 := xy1 + ',';&#xA;          if i = 14 then xy2 := xy2 + ']' else xy2 := xy2 + ',';&#xA;          if i = 14 then xyg := xyg + ']' else xyg := xyg + ',';&#xA;         end;&#xA;        st := AddXmlPath(trr, 'Rbf.A'); st.XY := xy;&#xA;        st := AddXmlPath(trr, 'Rbf.K1'); st.XY := xy1;&#xA;        st := AddXmlPath(trr, 'Rbf.K2'); st.XY := xy2;&#xA;        st := AddXmlPath(trr, 'Rbf.G'); st.XY := xyg;&#xA;       end;&#xA;&#xA;   else FindPoint;&#xA;  end;&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d: Variant;&#xA;begin&#xA;  for i := 1 to 14 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i));&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    d := AddXmlPath(s,'нк1');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;    d := AddXmlPath(s,'нк2');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;    d := AddXmlPath(s,'нгк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;   end;&#xA;&#xA; t.STEP1.KP := 'Вода';&#xA; t.STEP2.KP := '0.6';&#xA; t.STEP3.KP := '18.2';&#xA; t.STEP4.KP := '36.5';&#xA;&#xA; t.STEP5.KP := '0.7';&#xA; t.STEP6.KP := '18.2';&#xA; t.STEP7.KP := '36.5';&#xA;&#xA; t.STEP8.KP := '0.7';&#xA; t.STEP9.KP := '18.2';&#xA; t.STEP10.KP := '36.5';&#xA;&#xA; t.STEP11.KP := 'Вода';&#xA; t.STEP12.KP := '0.7';&#xA; t.STEP13.KP := '18.2';&#xA; t.STEP14.KP := '36.5';&#xA;&#xA; t.STEP1.D := 124;&#xA; t.STEP2.D := 124;&#xA; t.STEP3.D := 124;&#xA; t.STEP4.D := 124;&#xA;&#xA; t.STEP5.D := 156;&#xA; t.STEP6.D := 156;&#xA; t.STEP7.D := 156;&#xA;&#xA; t.STEP8.D := 216;&#xA; t.STEP9.D := 216;&#xA; t.STEP10.D := 216;&#xA;&#xA; t.STEP11.D := 295;&#xA; t.STEP12.D := 295;&#xA; t.STEP13.D := 295;&#xA; t.STEP14.D := 295;&#xA;&#xA; t.STEP1.INFO := '1) 124  вода';&#xA; t.STEP2.INFO := '2) 124  0.6';&#xA; t.STEP3.INFO := '3) 124  18.2';&#xA; t.STEP4.INFO := '4) 124  36.5';&#xA;&#xA; t.STEP5.INFO := '5) 156  0.7';&#xA; t.STEP6.INFO := '6) 156  18.2';&#xA; t.STEP7.INFO := '7) 156  36.5';&#xA;&#xA; t.STEP8.INFO := '8) 216  0.7';&#xA; t.STEP9.INFO := '9) 216  18.2';&#xA; t.STEP10.INFO := '10) 216  36.5';&#xA;&#xA; t.STEP11.INFO := '10) 295  вода';&#xA; t.STEP12.INFO := '11) 295  0.7';&#xA; t.STEP13.INFO := '12) 295  18.2';&#xA; t.STEP14.INFO := '13) 295  36.5';&#xA; end;&#xA;&#xA;">
				<IMPORT/>
				<EXPORT/>
			</TNNK>
			<TNNK_old EXEC_METR="&#xA;var&#xA;  k, k1, k2, kg: Double;&#xA;&#xA;procedure execute_step(stp: integer; alg, trr: variant);&#xA;&#xA; var&#xA;  st: variant;&#xA;  i: Integer;&#xA;  dia, xy, xy1, xy2, xyg: string;&#xA;&#xA;  procedure FindPoint;&#xA;  begin&#xA;    if st.нк2.DEV.VALUE = 0 then st.nkw := k * st.нк1.DEV.VALUE else st.nkw := k * st.нк1.DEV.VALUE/st.нк2.DEV.VALUE;&#xA;    if st.нк1.DEV.VALUE = 0 then st.nkw1 := k1 else st.nkw1 := k1/st.нк1.DEV.VALUE;&#xA;    if st.нк2.DEV.VALUE = 0 then st.nkw2 := k2 else st.nkw2 := k2/st.нк2.DEV.VALUE;&#xA;    if st.нгк.DEV.VALUE = 0 then st.nkwg := kg else st.nkwg := kg/st.нгк.DEV.VALUE;&#xA;  end;&#xA;&#xA;begin&#xA;  st := AddXmlPath(alg, 'STEP' + IntToStr(stp));&#xA;&#xA;  case stp of&#xA;   1,&#xA;   6,&#xA;   10: begin&#xA;        k1 := st.нк1.DEV.VALUE;&#xA;        k2 := st.нк2.DEV.VALUE;&#xA;        kg := st.нгк.DEV.VALUE;&#xA;        if k1 = 0 then k := k2 else k := k2/k1;&#xA;        FindPoint;&#xA;       end;&#xA;&#xA;   13: begin&#xA;        // обязательно *1 иначе считает что вариант - строка&#xA;        k1 := (alg.STEP1.нк1.DEV.VALUE*1 + alg.STEP6.нк1.DEV.VALUE*1 + alg.STEP10.нк1.DEV.VALUE*1)/3;&#xA;        k2 := (alg.STEP1.нк2.DEV.VALUE*1 + alg.STEP6.нк2.DEV.VALUE*1 + alg.STEP10.нк2.DEV.VALUE*1)/3;&#xA;        kg := (alg.STEP1.нгк.DEV.VALUE*1 + alg.STEP6.нгк.DEV.VALUE*1 + alg.STEP10.нгк.DEV.VALUE*1)/3;&#xA;        if k1 = 0 then k := k2 else k := k2/k1;&#xA;        // коэфф полученн при тарировке&#xA;        trr.KW1 := k1;&#xA;        trr.KW2 := k2;&#xA;        //trr.KW := k; лишнее&#xA;        trr.KWG := kg;&#xA;        xy := '[';  xy1 := '['; xy2 := '['; xyg := '[';&#xA;        for i := 1 to 13 do&#xA;         begin&#xA;          st := AddXmlPath(alg, 'STEP' + IntToStr(i));&#xA;          FindPoint;&#xA;          if i in [1,6,10] then Continue;&#xA;          dia := FloatToStr(st.D/200);&#xA;          xy  := xy  + '[' + dia + ',' +st.nkw  + ',' + st.KP + ']';&#xA;          xy1 := xy1 + '[' + dia + ',' +st.nkw1 + ',' + st.KP + ']';&#xA;          xy2 := xy2 + '[' + dia + ',' +st.nkw2 + ',' + st.KP + ']';&#xA;          xyg := xyg + '[' + dia + ',' +st.nkwg + ',' + st.KP + ']';&#xA;          if i = 13 then xy  := xy  + ']' else xy  := xy  + ',';&#xA;          if i = 13 then xy1 := xy1 + ']' else xy1 := xy1 + ',';&#xA;          if i = 13 then xy2 := xy2 + ']' else xy2 := xy2 + ',';&#xA;          if i = 13 then xyg := xyg + ']' else xyg := xyg + ',';&#xA;         end;&#xA;        st := AddXmlPath(trr, 'Rbf.A'); st.XY := xy;&#xA;        st := AddXmlPath(trr, 'Rbf.K1'); st.XY := xy1;&#xA;        st := AddXmlPath(trr, 'Rbf.K2'); st.XY := xy2;&#xA;        st := AddXmlPath(trr, 'Rbf.G'); st.XY := xyg;&#xA;       end;&#xA;&#xA;   else FindPoint;&#xA;  end;&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;" SETUP_METR=" var&#xA;  i: Integer;&#xA;  s, d: Variant;&#xA;begin&#xA;  for i := 1 to 13 do&#xA;   begin&#xA;    s := AddXmlPath(t, 'STEP'+IntToStr(i) );&#xA;    s.EXECUTED := False;&#xA;    s.STEP := i;&#xA;    d := AddXmlPath(s,'нк1');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;    d := AddXmlPath(s,'нк2');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;    d := AddXmlPath(s,'нгк');&#xA;    AddXmlPath(d,'CLC');&#xA;    AddXmlPath(d,'DEV');&#xA;    d.CLC.VALUE := 0;&#xA;    d.DEV.VALUE := 0;&#xA;   end;&#xA;&#xA; t.STEP1.KP := 'Вода';&#xA; t.STEP2.KP := '0.6';&#xA; t.STEP3.KP := '8.1';&#xA; t.STEP4.KP := '15';&#xA; t.STEP5.KP := '30.9';&#xA; t.STEP6.KP := 'Вода';&#xA; t.STEP7.KP := '0.7';&#xA; t.STEP8.KP := '15.7';&#xA; t.STEP9.KP := '35.5';&#xA; t.STEP10.KP := 'Вода';&#xA; t.STEP11.KP := '0.6';&#xA; t.STEP12.KP := '15.6';&#xA; t.STEP13.KP := '36';&#xA;&#xA; t.STEP1.D := 196;&#xA; t.STEP2.D := 196;&#xA; t.STEP3.D := 196;&#xA; t.STEP4.D := 196;&#xA; t.STEP5.D := 196;&#xA;&#xA; t.STEP6.D := 156;&#xA; t.STEP7.D := 156;&#xA; t.STEP8.D := 156;&#xA; t.STEP9.D := 156;&#xA;&#xA; t.STEP10.D := 124;&#xA; t.STEP11.D := 124;&#xA; t.STEP12.D := 124;&#xA; t.STEP13.D := 124;&#xA;&#xA; t.STEP1.INFO := '1) 196  вода';&#xA; t.STEP2.INFO := '2) 196  0.6';&#xA; t.STEP3.INFO := '3) 196  8.1';&#xA; t.STEP4.INFO := '4) 196  15';&#xA; t.STEP5.INFO := '5) 196  30.9';&#xA; t.STEP6.INFO := '6) 156  вода';&#xA; t.STEP7.INFO := '7) 156  0.7';&#xA; t.STEP8.INFO := '8) 156  15.7';&#xA; t.STEP9.INFO := '9) 156  35.5';&#xA; t.STEP10.INFO := '10) 124  вода';&#xA; t.STEP11.INFO := '11) 124  0.6';&#xA; t.STEP12.INFO := '12) 124  15.6';&#xA; t.STEP13.INFO := '13) 124  36';&#xA;end;&#xA;&#xA;">
				<IMPORT IMPORT0="&#xA;function GetFilterName: string;&#xA;begin&#xA;  Result := 'Импортирование-ННК 10 моделей(*.nnk)|*.nnk';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA;  ImportNNK10(TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
				<EXPORT EXPORT0="function GetFilterName: string;&#xA;begin&#xA;  Result := 'Экспортирование-ННК 10 моделей(*.nnk)|*.nnk';&#xA;end;&#xA;&#xA;procedure OnExecuteFilter(const TrrFile: string; NewTrr: variant);&#xA;begin&#xA; // ImportNNK10(TrrFile, NewTrr);&#xA;end;&#xA;&#xA;begin&#xA;end.&#xA;"/>
			</TNNK_old>
		</MODEL>
	</ННК>
</TRR>
